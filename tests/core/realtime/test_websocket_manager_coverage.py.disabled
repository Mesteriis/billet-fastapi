"""
Комплексные тесты для WebSocket менеджера с высоким покрытием.
"""

import asyncio
import json
import uuid
from unittest.mock import AsyncMock, Mock, patch

import pytest
from fastapi import WebSocket, WebSocketDisconnect

from core.realtime.connection_manager import connection_manager


@pytest.mark.unit
@pytest.mark.realtime
class TestConnectionManager:
    """Тесты для ConnectionManager."""

    @pytest.fixture
    def connection_manager(self):
        """Фикстура ConnectionManager."""
        return ConnectionManager()

    @pytest.fixture
    def mock_websocket(self):
        """Мокированный WebSocket."""
        websocket = Mock(spec=WebSocket)
        websocket.client.host = "127.0.0.1"
        websocket.client.port = 8000
        return websocket

    @pytest.fixture
    def user_id(self):
        """ID пользователя для тестов."""
        return str(uuid.uuid4())

    def test_connection_manager_init(self, connection_manager):
        """Тест инициализации ConnectionManager."""
        assert connection_manager.active_connections == {}
        assert connection_manager.user_connections == {}
        assert connection_manager.room_connections == {}

    async def test_connect_user(self, connection_manager, mock_websocket, user_id):
        """Тест подключения пользователя."""
        connection_id = "test_connection"

        await connection_manager.connect(mock_websocket, connection_id, user_id)

        assert connection_id in connection_manager.active_connections
        assert connection_manager.active_connections[connection_id]["websocket"] == mock_websocket
        assert connection_manager.active_connections[connection_id]["user_id"] == user_id
        assert user_id in connection_manager.user_connections
        assert connection_id in connection_manager.user_connections[user_id]

    async def test_connect_multiple_connections_same_user(self, connection_manager, user_id):
        """Тест подключения нескольких соединений для одного пользователя."""
        websocket1 = Mock(spec=WebSocket)
        websocket2 = Mock(spec=WebSocket)
        connection_id1 = "connection_1"
        connection_id2 = "connection_2"

        await connection_manager.connect(websocket1, connection_id1, user_id)
        await connection_manager.connect(websocket2, connection_id2, user_id)

        assert len(connection_manager.user_connections[user_id]) == 2
        assert connection_id1 in connection_manager.user_connections[user_id]
        assert connection_id2 in connection_manager.user_connections[user_id]

    async def test_disconnect_user(self, connection_manager, mock_websocket, user_id):
        """Тест отключения пользователя."""
        connection_id = "test_connection"

        await connection_manager.connect(mock_websocket, connection_id, user_id)
        await connection_manager.disconnect(connection_id)

        assert connection_id not in connection_manager.active_connections
        assert user_id not in connection_manager.user_connections

    async def test_disconnect_nonexistent_connection(self, connection_manager):
        """Тест отключения несуществующего соединения."""
        # Не должно вызывать ошибок
        await connection_manager.disconnect("nonexistent_connection")

    async def test_join_room(self, connection_manager, mock_websocket, user_id):
        """Тест присоединения к комнате."""
        connection_id = "test_connection"
        room_id = "test_room"

        await connection_manager.connect(mock_websocket, connection_id, user_id)
        await connection_manager.join_room(connection_id, room_id)

        assert room_id in connection_manager.room_connections
        assert connection_id in connection_manager.room_connections[room_id]
        assert connection_manager.active_connections[connection_id]["rooms"] == {room_id}

    async def test_leave_room(self, connection_manager, mock_websocket, user_id):
        """Тест выхода из комнаты."""
        connection_id = "test_connection"
        room_id = "test_room"

        await connection_manager.connect(mock_websocket, connection_id, user_id)
        await connection_manager.join_room(connection_id, room_id)
        await connection_manager.leave_room(connection_id, room_id)

        assert (
            room_id not in connection_manager.room_connections
            or connection_id not in connection_manager.room_connections[room_id]
        )
        assert room_id not in connection_manager.active_connections[connection_id]["rooms"]

    async def test_send_personal_message(self, connection_manager, mock_websocket, user_id):
        """Тест отправки личного сообщения."""
        connection_id = "test_connection"
        message = {"type": "test", "data": "Hello"}

        mock_websocket.send_text = AsyncMock()

        await connection_manager.connect(mock_websocket, connection_id, user_id)
        await connection_manager.send_personal_message(user_id, message)

        mock_websocket.send_text.assert_called_once_with(json.dumps(message))

    async def test_send_personal_message_to_offline_user(self, connection_manager):
        """Тест отправки сообщения офлайн пользователю."""
        offline_user_id = str(uuid.uuid4())
        message = {"type": "test", "data": "Hello"}

        # Не должно вызывать ошибок
        await connection_manager.send_personal_message(offline_user_id, message)

    async def test_send_room_message(self, connection_manager, user_id):
        """Тест отправки сообщения в комнату."""
        connection_id1 = "connection_1"
        connection_id2 = "connection_2"
        room_id = "test_room"
        message = {"type": "room_message", "data": "Hello room"}

        websocket1 = Mock(spec=WebSocket)
        websocket2 = Mock(spec=WebSocket)
        websocket1.send_text = AsyncMock()
        websocket2.send_text = AsyncMock()

        await connection_manager.connect(websocket1, connection_id1, user_id)
        await connection_manager.connect(websocket2, connection_id2, f"{user_id}_2")
        await connection_manager.join_room(connection_id1, room_id)
        await connection_manager.join_room(connection_id2, room_id)

        await connection_manager.send_room_message(room_id, message)

        websocket1.send_text.assert_called_once_with(json.dumps(message))
        websocket2.send_text.assert_called_once_with(json.dumps(message))

    async def test_broadcast_message(self, connection_manager, user_id):
        """Тест широковещательной отправки сообщения."""
        connection_id1 = "connection_1"
        connection_id2 = "connection_2"
        message = {"type": "broadcast", "data": "Hello everyone"}

        websocket1 = Mock(spec=WebSocket)
        websocket2 = Mock(spec=WebSocket)
        websocket1.send_text = AsyncMock()
        websocket2.send_text = AsyncMock()

        await connection_manager.connect(websocket1, connection_id1, user_id)
        await connection_manager.connect(websocket2, connection_id2, f"{user_id}_2")

        await connection_manager.broadcast(message)

        websocket1.send_text.assert_called_once_with(json.dumps(message))
        websocket2.send_text.assert_called_once_with(json.dumps(message))

    def test_get_user_connections(self, connection_manager, user_id):
        """Тест получения соединений пользователя."""
        connection_manager.user_connections[user_id] = {"conn1", "conn2"}

        connections = connection_manager.get_user_connections(user_id)

        assert connections == {"conn1", "conn2"}

    def test_get_user_connections_nonexistent(self, connection_manager):
        """Тест получения соединений несуществующего пользователя."""
        connections = connection_manager.get_user_connections("nonexistent_user")
        assert connections == set()

    def test_get_room_connections(self, connection_manager):
        """Тест получения соединений комнаты."""
        room_id = "test_room"
        connection_manager.room_connections[room_id] = {"conn1", "conn2"}

        connections = connection_manager.get_room_connections(room_id)

        assert connections == {"conn1", "conn2"}

    def test_get_room_connections_nonexistent(self, connection_manager):
        """Тест получения соединений несуществующей комнаты."""
        connections = connection_manager.get_room_connections("nonexistent_room")
        assert connections == set()

    def test_get_active_connections_count(self, connection_manager):
        """Тест получения количества активных соединений."""
        connection_manager.active_connections = {"conn1": {}, "conn2": {}, "conn3": {}}

        count = connection_manager.get_active_connections_count()

        assert count == 3

    def test_get_users_count(self, connection_manager):
        """Тест получения количества подключенных пользователей."""
        connection_manager.user_connections = {"user1": {"conn1"}, "user2": {"conn2", "conn3"}, "user3": {"conn4"}}

        count = connection_manager.get_users_count()

        assert count == 3


@pytest.mark.unit
@pytest.mark.realtime
class TestWebSocketManager:
    """Тесты для WebSocketManager."""

    @pytest.fixture
    def websocket_manager(self):
        """Фикстура WebSocketManager."""
        return WebSocketManager()

    @pytest.fixture
    def mock_connection_manager(self, monkeypatch):
        """Мокированный ConnectionManager."""
        mock_manager = AsyncMock(spec=ConnectionManager)
        monkeypatch.setattr("core.realtime.websocket_manager.ConnectionManager", lambda: mock_manager)
        return mock_manager

    @pytest.fixture
    def mock_websocket(self):
        """Мокированный WebSocket."""
        websocket = Mock(spec=WebSocket)
        websocket.accept = AsyncMock()
        websocket.receive_text = AsyncMock()
        websocket.close = AsyncMock()
        return websocket

    async def test_websocket_manager_init(self, websocket_manager):
        """Тест инициализации WebSocketManager."""
        assert websocket_manager.connection_manager is not None

    async def test_connect_websocket(self, websocket_manager, mock_websocket, mock_connection_manager):
        """Тест подключения WebSocket."""
        user_id = str(uuid.uuid4())

        await websocket_manager.connect(mock_websocket, user_id)

        mock_websocket.accept.assert_called_once()
        mock_connection_manager.connect.assert_called_once()

    async def test_disconnect_websocket(self, websocket_manager, mock_connection_manager):
        """Тест отключения WebSocket."""
        connection_id = "test_connection"

        await websocket_manager.disconnect(connection_id)

        mock_connection_manager.disconnect.assert_called_once_with(connection_id)

    async def test_handle_message_json(self, websocket_manager):
        """Тест обработки JSON сообщения."""
        message = '{"type": "test", "data": "Hello"}'

        with patch.object(websocket_manager, "_handle_message_type") as mock_handle:
            await websocket_manager.handle_message(message, "test_connection", "user_id")

            mock_handle.assert_called_once_with({"type": "test", "data": "Hello"}, "test_connection", "user_id")

    async def test_handle_message_invalid_json(self, websocket_manager):
        """Тест обработки невалидного JSON."""
        message = "invalid json"

        # Не должно вызывать ошибок
        await websocket_manager.handle_message(message, "test_connection", "user_id")

    async def test_handle_join_room_message(self, websocket_manager, mock_connection_manager):
        """Тест обработки сообщения присоединения к комнате."""
        websocket_manager.connection_manager = mock_connection_manager
        message = {"type": "join_room", "room_id": "test_room"}

        await websocket_manager._handle_message_type(message, "test_connection", "user_id")

        mock_connection_manager.join_room.assert_called_once_with("test_connection", "test_room")

    async def test_handle_leave_room_message(self, websocket_manager, mock_connection_manager):
        """Тест обработки сообщения выхода из комнаты."""
        websocket_manager.connection_manager = mock_connection_manager
        message = {"type": "leave_room", "room_id": "test_room"}

        await websocket_manager._handle_message_type(message, "test_connection", "user_id")

        mock_connection_manager.leave_room.assert_called_once_with("test_connection", "test_room")

    async def test_handle_send_room_message(self, websocket_manager, mock_connection_manager):
        """Тест обработки отправки сообщения в комнату."""
        websocket_manager.connection_manager = mock_connection_manager
        message = {"type": "send_room_message", "room_id": "test_room", "message": {"text": "Hello room"}}

        await websocket_manager._handle_message_type(message, "test_connection", "user_id")

        mock_connection_manager.send_room_message.assert_called_once_with("test_room", {"text": "Hello room"})

    async def test_handle_ping_message(self, websocket_manager, mock_connection_manager):
        """Тест обработки ping сообщения."""
        websocket_manager.connection_manager = mock_connection_manager
        message = {"type": "ping"}

        await websocket_manager._handle_message_type(message, "test_connection", "user_id")

        # Должен отправить pong ответ
        mock_connection_manager.send_personal_message.assert_called_once()
        args = mock_connection_manager.send_personal_message.call_args[0]
        assert args[1]["type"] == "pong"

    async def test_handle_unknown_message_type(self, websocket_manager):
        """Тест обработки неизвестного типа сообщения."""
        message = {"type": "unknown_type", "data": "test"}

        # Не должно вызывать ошибок
        await websocket_manager._handle_message_type(message, "test_connection", "user_id")

    async def test_send_to_user(self, websocket_manager, mock_connection_manager):
        """Тест отправки сообщения пользователю."""
        websocket_manager.connection_manager = mock_connection_manager
        user_id = str(uuid.uuid4())
        message = {"type": "notification", "data": "Hello"}

        await websocket_manager.send_to_user(user_id, message)

        mock_connection_manager.send_personal_message.assert_called_once_with(user_id, message)

    async def test_send_to_room(self, websocket_manager, mock_connection_manager):
        """Тест отправки сообщения в комнату."""
        websocket_manager.connection_manager = mock_connection_manager
        room_id = "test_room"
        message = {"type": "room_notification", "data": "Hello room"}

        await websocket_manager.send_to_room(room_id, message)

        mock_connection_manager.send_room_message.assert_called_once_with(room_id, message)

    async def test_broadcast(self, websocket_manager, mock_connection_manager):
        """Тест широковещательной отправки."""
        websocket_manager.connection_manager = mock_connection_manager
        message = {"type": "system_notification", "data": "System message"}

        await websocket_manager.broadcast(message)

        mock_connection_manager.broadcast.assert_called_once_with(message)

    def test_get_stats(self, websocket_manager, mock_connection_manager):
        """Тест получения статистики."""
        websocket_manager.connection_manager = mock_connection_manager
        mock_connection_manager.get_active_connections_count.return_value = 10
        mock_connection_manager.get_users_count.return_value = 8

        stats = websocket_manager.get_stats()

        assert stats["active_connections"] == 10
        assert stats["active_users"] == 8
        assert "rooms" in stats

    async def test_error_handling_in_message_processing(self, websocket_manager):
        """Тест обработки ошибок при обработке сообщений."""
        # Создаем сообщение, которое вызовет ошибку
        with patch.object(websocket_manager, "_handle_message_type", side_effect=Exception("Test error")):
            # Не должно вызывать необработанное исключение
            await websocket_manager.handle_message('{"type": "test"}', "conn_id", "user_id")

    async def test_websocket_lifecycle(self, websocket_manager, mock_websocket):
        """Тест полного жизненного цикла WebSocket соединения."""
        user_id = str(uuid.uuid4())

        # Подключение
        await websocket_manager.connect(mock_websocket, user_id)

        # Обработка сообщений
        await websocket_manager.handle_message('{"type": "ping"}', "connection_id", user_id)

        # Отключение
        await websocket_manager.disconnect("connection_id")

        # Проверяем что все методы были вызваны без ошибок
        mock_websocket.accept.assert_called_once()


@pytest.mark.unit
@pytest.mark.realtime
class TestWebSocketErrorHandling:
    """Тесты обработки ошибок в WebSocket."""

    @pytest.fixture
    def connection_manager(self):
        """Фикстура ConnectionManager."""
        return ConnectionManager()

    async def test_send_message_to_closed_websocket(self, connection_manager):
        """Тест отправки сообщения в закрытый WebSocket."""
        mock_websocket = Mock(spec=WebSocket)
        mock_websocket.send_text = AsyncMock(side_effect=WebSocketDisconnect(code=1000))

        user_id = str(uuid.uuid4())
        connection_id = "test_connection"

        await connection_manager.connect(mock_websocket, connection_id, user_id)

        # Отправка сообщения в закрытый WebSocket не должна вызывать ошибку
        await connection_manager.send_personal_message(user_id, {"type": "test"})

    async def test_send_message_with_connection_error(self, connection_manager):
        """Тест отправки сообщения с ошибкой соединения."""
        mock_websocket = Mock(spec=WebSocket)
        mock_websocket.send_text = AsyncMock(side_effect=ConnectionError("Connection lost"))

        user_id = str(uuid.uuid4())
        connection_id = "test_connection"

        await connection_manager.connect(mock_websocket, connection_id, user_id)

        # Ошибка соединения должна быть обработана
        await connection_manager.send_personal_message(user_id, {"type": "test"})

    async def test_concurrent_connections_same_user(self, connection_manager):
        """Тест одновременных подключений одного пользователя."""
        user_id = str(uuid.uuid4())

        # Создаем несколько одновременных подключений
        tasks = []
        for i in range(5):
            websocket = Mock(spec=WebSocket)
            connection_id = f"connection_{i}"
            task = asyncio.create_task(connection_manager.connect(websocket, connection_id, user_id))
            tasks.append(task)

        await asyncio.gather(*tasks)

        # Все подключения должны быть зарегистрированы
        assert len(connection_manager.user_connections[user_id]) == 5

    async def test_memory_cleanup_on_disconnect(self, connection_manager):
        """Тест очистки памяти при отключении."""
        user_id = str(uuid.uuid4())
        room_id = "test_room"
        connection_id = "test_connection"

        mock_websocket = Mock(spec=WebSocket)

        # Подключаемся и присоединяемся к комнате
        await connection_manager.connect(mock_websocket, connection_id, user_id)
        await connection_manager.join_room(connection_id, room_id)

        # Проверяем что данные есть
        assert connection_id in connection_manager.active_connections
        assert user_id in connection_manager.user_connections
        assert room_id in connection_manager.room_connections

        # Отключаемся
        await connection_manager.disconnect(connection_id)

        # Проверяем очистку
        assert connection_id not in connection_manager.active_connections
        assert user_id not in connection_manager.user_connections
        assert (
            room_id not in connection_manager.room_connections or len(connection_manager.room_connections[room_id]) == 0
        )
