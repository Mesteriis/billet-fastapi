"""
TestStaticSchema service implementation for Advanced level.

This file was auto-generated by Autogen CLI.
Application: test_static_schemas
Level: Enterprise
Generated at: 2025-06-22T18:01:28.021260
"""

from typing import Optional, Any
import logging
import json

from sqlalchemy.ext.asyncio import AsyncSession

from apps.test_static_schemas.repo.test_static_schemas_repo import TestStaticSchemaRepository
from apps.test_static_schemas.schemas.test_static_schemas_schemas import (
    TestStaticSchemaCreate,
    TestStaticSchemaUpdate,
    TestStaticSchemaResponse,
    TestStaticSchemaList,
    TestStaticSchemaSearchRequest,
    TestStaticSchemaStatus
)
from apps.test_static_schemas.exceptions import (
    TestStaticSchemaServiceException,
    TestStaticSchemaValidationException,
    TestStaticSchemaAlreadyExistsError,
    TestStaticSchemaNotFoundError
)

logger = logging.getLogger("test_static_schemas.teststaticschema")


class TestStaticSchemaService:
    """
    Advanced service layer for TestStaticSchema business logic.
    
    This service provides advanced business logic operations including:
    - Complex validation and business rules
    - Full-text search with relevance scoring
    - Advanced filtering and faceted search
    - Priority and status management
    - Tag-based categorization
    - Comprehensive error handling
    - Advanced soft delete operations
    
    Example:
        >>> async with async_session() as session:
        ...     service = TestStaticSchemaService(session)
        ...     
        ...     # Advanced search
        ...     search_request = TestStaticSchemaSearchRequest(
        ...         query="business critical",
        ...         priority_gte=5,
        ...         status=["active", "draft"],
        ...         include_facets=True
        ...     )
        ...     results = await service.search_teststaticschemas(search_request)
    """

    def __init__(self, session: AsyncSession):
        """Initialize TestStaticSchema service."""
        self.session = session
        self.repository = TestStaticSchemaRepository(session)

    async def create_teststaticschema(self, create_data: TestStaticSchemaCreate) -> TestStaticSchemaResponse:
        """Create a new teststaticschema with advanced validation."""
        try:
            await self._validate_create_data(create_data)
            
            # Process tags
            processed_data = create_data.model_copy()
            if processed_data.tags:
                processed_data.tags = json.dumps(processed_data.tags)
            
            logger.info(f"Creating advanced teststaticschema: {create_data.name}")
            entity = await self.repository.create(processed_data)
            
            return await self._build_response(entity)
            
        except (TestStaticSchemaValidationException, TestStaticSchemaAlreadyExistsError):
            raise
        except Exception as e:
            logger.error(f"Failed to create teststaticschema: {e}")
            raise TestStaticSchemaServiceException(
                f"Failed to create teststaticschema: {str(e)}",
                operation="create_teststaticschema"
            ) from e

    async def get_teststaticschema(self, teststaticschema_id: int) -> Optional[TestStaticSchemaResponse]:
        """
        Get teststaticschema by ID with computed fields.
        
        Args:
            teststaticschema_id: ID of the teststaticschema to retrieve
            
        Returns:
            TestStaticSchema response with computed fields if found, None otherwise
            
        Raises:
            TestStaticSchemaServiceException: If retrieval fails
            
        Example:
            >>> teststaticschema = await service.get_teststaticschema(123)
            >>> if teststaticschema:
            ...     print(f"Found: {teststaticschema.name} (Priority: {teststaticschema.priority})")
        """
        try:
            logger.debug(f"Getting teststaticschema with ID: {teststaticschema_id}")
            entity = await self.repository.get(teststaticschema_id)
            
            if entity:
                return await self._build_response(entity)
            return None
            
        except Exception as e:
            logger.error(f"Failed to get teststaticschema {teststaticschema_id}: {e}")
            raise TestStaticSchemaServiceException(
                f"Failed to retrieve teststaticschema: {str(e)}",
                operation="get_teststaticschema"
            ) from e

    async def update_teststaticschema(
        self, 
        teststaticschema_id: int, 
        update_data: TestStaticSchemaUpdate
    ) -> Optional[TestStaticSchemaResponse]:
        """
        Update teststaticschema with advanced business validation.
        
        Args:
            teststaticschema_id: ID of the teststaticschema to update
            update_data: Data for updating the teststaticschema
            
        Returns:
            Updated teststaticschema response if found
            
        Raises:
            TestStaticSchemaValidationException: If validation fails
            TestStaticSchemaNotFoundError: If teststaticschema not found
            TestStaticSchemaServiceException: If update fails
            
        Example:
            >>> data = TestStaticSchemaUpdate(
            ...     name="Updated Name",
            ...     priority=9,
            ...     tags=["updated", "high-priority"]
            ... )
            >>> updated = await service.update_teststaticschema(123, data)
        """
        try:
            # Check if entity exists
            existing = await self.repository.get(teststaticschema_id)
            if not existing:
                raise TestStaticSchemaNotFoundError(
                    f"TestStaticSchema with ID {teststaticschema_id} not found",
                    entity_id=teststaticschema_id
                )
            
            # Advanced business validation
            await self._validate_update_data(update_data, teststaticschema_id)
            
            # Process tags if provided
            processed_data = update_data.model_copy()
            if processed_data.tags is not None:
                processed_data.tags = json.dumps(processed_data.tags) if processed_data.tags else None
            
            # Update entity
            logger.info(f"Updating teststaticschema {teststaticschema_id}")
            entity = await self.repository.update(teststaticschema_id, processed_data)
            
            if entity:
                response = await self._build_response(entity)
                logger.info(f"Updated teststaticschema {teststaticschema_id}")
                return response
            return None
            
        except (TestStaticSchemaValidationException, TestStaticSchemaNotFoundError):
            raise
        except Exception as e:
            logger.error(f"Failed to update teststaticschema {teststaticschema_id}: {e}")
            raise TestStaticSchemaServiceException(
                f"Failed to update teststaticschema: {str(e)}",
                operation="update_teststaticschema"
            ) from e

    async def delete_teststaticschema(self, teststaticschema_id: int) -> bool:
        """
        Delete teststaticschema by ID (soft delete if enabled).
        
        Args:
            teststaticschema_id: ID of the teststaticschema to delete
            
        Returns:
            True if deleted successfully, False if not found
            
        Raises:
            TestStaticSchemaServiceException: If deletion fails
            
        Example:
            >>> success = await service.delete_teststaticschema(123)
            >>> if success:
            ...     print("TestStaticSchema deleted successfully")
        """
        try:
            logger.info(f"Deleting teststaticschema {teststaticschema_id}")
            success = await self.repository.remove(teststaticschema_id)
            
            if success:
                logger.info(f"Deleted teststaticschema {teststaticschema_id}")
            else:
                logger.warning(f"TestStaticSchema {teststaticschema_id} not found for deletion")
                
            return success
            
        except Exception as e:
            logger.error(f"Failed to delete teststaticschema {teststaticschema_id}: {e}")
            raise TestStaticSchemaServiceException(
                f"Failed to delete teststaticschema: {str(e)}",
                operation="delete_teststaticschema"
            ) from e

    async def search_teststaticschemas(self, search_request: TestStaticSchemaSearchRequest) -> TestStaticSchemaList:
        """Advanced search with complex filtering."""
        try:
            logger.debug(f"Advanced search teststaticschemas")
            return await self.repository.complex_search(search_request)
        except Exception as e:
            logger.error(f"Failed to search teststaticschemas: {e}")
            raise TestStaticSchemaServiceException(
                f"Failed to search teststaticschemas: {str(e)}",
                operation="search_teststaticschemas"
            ) from e

    async def get_teststaticschema_by_name(self, name: str, status: Optional[TestStaticSchemaStatus] = None) -> Optional[TestStaticSchemaResponse]:
        """
        Get teststaticschema by name with optional status filter.
        
        Args:
            name: Name to search for
            status: Optional status filter
            
        Returns:
            TestStaticSchema response if found
            
        Example:
            >>> teststaticschema = await service.get_teststaticschema_by_name("Project Alpha", "active")
        """
        try:
            entity = await self.repository.get_by_name_and_status(
                name, status or TestStaticSchemaStatus.ACTIVE
            )
            if entity:
                return await self._build_response(entity)
            return None
        except Exception as e:
            logger.error(f"Failed to get teststaticschema by name '{name}': {e}")
            raise TestStaticSchemaServiceException(
                f"Failed to get teststaticschema by name: {str(e)}",
                operation="get_teststaticschema_by_name"
            ) from e

    async def update_priority(self, teststaticschema_id: int, priority: int) -> Optional[TestStaticSchemaResponse]:
        """
        Update teststaticschema priority with validation.
        
        Args:
            teststaticschema_id: ID of the teststaticschema to update
            priority: New priority (0-10)
            
        Returns:
            Updated teststaticschema response
            
        Raises:
            TestStaticSchemaValidationException: If priority is invalid
            
        Example:
            >>> updated = await service.update_priority(123, 9)
        """
        if not (0 <= priority <= 10):
            raise TestStaticSchemaValidationException(
                "Priority must be between 0 and 10",
                validation_errors=[{"field": "priority", "message": "Invalid priority range"}]
            )
        
        update_data = TestStaticSchemaUpdate(priority=priority)
        return await self.update_teststaticschema(teststaticschema_id, update_data)

    async def add_tags(self, teststaticschema_id: int, tags: list[str]) -> Optional[TestStaticSchemaResponse]:
        """
        Add tags to teststaticschema.
        
        Args:
            teststaticschema_id: ID of the teststaticschema
            tags: List of tags to add
            
        Returns:
            Updated teststaticschema response
            
        Example:
            >>> updated = await service.add_tags(123, ["urgent", "customer"])
        """
        entity = await self.repository.get(teststaticschema_id)
        if not entity:
            raise TestStaticSchemaNotFoundError(f"TestStaticSchema with ID {teststaticschema_id} not found")
        
        # Merge with existing tags
        existing_tags = set(entity.tags_list)
        new_tags = list(existing_tags.union(set(tags)))
        
        update_data = TestStaticSchemaUpdate(tags=new_tags)
        return await self.update_teststaticschema(teststaticschema_id, update_data)

    async def get_statistics(self) -> dict[str, Any]:
        """
        Get comprehensive statistics about teststaticschemas.
        
        Returns:
            Dictionary with various statistics
            
        Example:
            >>> stats = await service.get_statistics()
            >>> print(f"Total active: {stats['total_active']}")
        """
        try:
            # Get basic counts
            total_count = await self.repository.count()
            active_count = await self.repository.count(filters={"status": "active", "is_deleted": False})
            
            # Get priority stats
            priority_stats = await self.repository.get_priority_stats()
            
            # Get status counts
            status_counts = await self.repository.get_status_counts()
            
            return {
                "total_count": total_count,
                "active_count": active_count,
                "priority_stats": priority_stats,
                "status_counts": status_counts,
                "high_priority_count": len(await self.repository.get_by_priority_range(7, 10))
            }
            
        except Exception as e:
            logger.error(f"Failed to get statistics: {e}")
            raise TestStaticSchemaServiceException(
                f"Failed to get statistics: {str(e)}",
                operation="get_statistics"
            ) from e

    # Private helper methods

    async def _build_response(self, entity) -> TestStaticSchemaResponse:
        """Build response object with computed fields."""
        response = TestStaticSchemaResponse.model_validate(entity)
        response.tags_count = len(entity.tags_list) if entity.tags else 0
        response.is_high_priority = entity.priority >= 7
        return response

    async def _validate_create_data(self, create_data: TestStaticSchemaCreate) -> None:
        """Advanced validation for create data."""
        # Check business rules
        if create_data.priority > 8 and create_data.status != TestStaticSchemaStatus.ACTIVE:
            raise TestStaticSchemaValidationException(
                "High priority teststaticschemas (>8) must be active",
                validation_errors=[{"field": "status", "message": "High priority items must be active"}]
            )

    async def _validate_update_data(self, update_data: TestStaticSchemaUpdate, teststaticschema_id: int) -> None:
        """Advanced validation for update data."""
        # Check if name already exists (excluding current entity)
        if update_data.name:
            existing = await self.repository.get_by_name_and_status(
                update_data.name, 
                update_data.status or TestStaticSchemaStatus.ACTIVE
            )
            if existing and existing.id != teststaticschema_id:
                raise TestStaticSchemaValidationException(
                    f"TestStaticSchema with name '{update_data.name}' already exists",
                    validation_errors=[{"field": "name", "message": "Name already exists"}]
                )
        
        # Validate business rules
        if update_data.priority and update_data.priority > 8:
            if update_data.status and update_data.status != TestStaticSchemaStatus.ACTIVE:
                raise TestStaticSchemaValidationException(
                    "High priority teststaticschemas (>8) must be active",
                    validation_errors=[{"field": "status", "message": "High priority items must be active"}]
                ) 