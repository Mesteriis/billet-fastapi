"""
TestStaticSchema logging middleware for Advanced level.

This file was auto-generated by Autogen CLI.
Application: test_static_schemas
Level: Enterprise
Generated at: 2025-06-22T18:01:28.021260
"""

import time
import uuid
from typing import Callable

from fastapi import Request, Response
from starlette.middleware.base import BaseHTTPMiddleware
import logging

logger = logging.getLogger("middleware.test_static_schemas")


class TestStaticSchemaLoggingMiddleware(BaseHTTPMiddleware):
    """
    Advanced logging middleware for TestStaticSchema operations.
    
    This middleware provides comprehensive request/response logging with:
    - Request ID generation for tracing
    - Performance metrics (response time)
    - Request/response body logging (configurable)
    - Error tracking and correlation
    - User activity tracking
    - API usage analytics
    
    Features:
    - Automatic request ID assignment
    - Performance monitoring
    - Structured logging with context
    - Error correlation and tracking
    - Configurable log levels per endpoint
    
    Example:
        >>> from fastapi import FastAPI
        >>> from apps.test_static_schemas.middleware.logging_middleware import TestStaticSchemaLoggingMiddleware
        >>> 
        >>> app = FastAPI()
        >>> app.add_middleware(TestStaticSchemaLoggingMiddleware)
    """

    def __init__(
        self,
        app,
        log_requests: bool = True,
        log_responses: bool = False,
        log_body: bool = False,
        performance_threshold_ms: float = 1000.0
    ):
        """
        Initialize logging middleware.
        
        Args:
            app: FastAPI application instance
            log_requests: Whether to log incoming requests
            log_responses: Whether to log outgoing responses
            log_body: Whether to log request/response bodies
            performance_threshold_ms: Threshold for slow request warnings
        """
        super().__init__(app)
        self.log_requests = log_requests
        self.log_responses = log_responses
        self.log_body = log_body
        self.performance_threshold_ms = performance_threshold_ms

    async def dispatch(self, request: Request, call_next: Callable) -> Response:
        """
        Process request through logging middleware.
        
        Args:
            request: Incoming HTTP request
            call_next: Next middleware or endpoint handler
            
        Returns:
            HTTP response with logging metadata
        """
        # Generate unique request ID for tracing
        request_id = str(uuid.uuid4())
        request.state.request_id = request_id
        
        # Start performance timer
        start_time = time.time()
        
        # Log incoming request
        if self.log_requests:
            await self._log_request(request, request_id)
        
        # Process request
        try:
            response = await call_next(request)
            
            # Calculate response time
            process_time = time.time() - start_time
            response_time_ms = process_time * 1000
            
            # Add response headers
            response.headers["X-Request-ID"] = request_id
            response.headers["X-Response-Time"] = f"{response_time_ms:.2f}ms"
            
            # Log response
            if self.log_responses:
                await self._log_response(request, response, request_id, response_time_ms)
            
            # Log performance warning if slow
            if response_time_ms > self.performance_threshold_ms:
                logger.warning(
                    f"Slow request detected",
                    extra={
                        "request_id": request_id,
                        "method": request.method,
                        "url": str(request.url),
                        "response_time_ms": response_time_ms,
                        "status_code": response.status_code,
                        "app": "test_static_schemas",
                        "model": "TestStaticSchema"
                    }
                )
            
            return response
            
        except Exception as e:
            # Calculate response time for errors
            process_time = time.time() - start_time
            response_time_ms = process_time * 1000
            
            # Log error
            logger.error(
                f"Request failed with exception: {str(e)}",
                extra={
                    "request_id": request_id,
                    "method": request.method,
                    "url": str(request.url),
                    "response_time_ms": response_time_ms,
                    "error_type": type(e).__name__,
                    "error_message": str(e),
                    "app": "test_static_schemas",
                    "model": "TestStaticSchema"
                },
                exc_info=True
            )
            
            # Re-raise the exception
            raise

    async def _log_request(self, request: Request, request_id: str) -> None:
        """
        Log incoming request details.
        
        Args:
            request: HTTP request object
            request_id: Unique request identifier
        """
        # Get client information
        client_ip = self._get_client_ip(request)
        user_agent = request.headers.get("User-Agent", "Unknown")
        
        # Get request body if enabled
        request_body = None
        if self.log_body and request.method in ["POST", "PUT", "PATCH"]:
            try:
                body = await request.body()
                if body:
                    request_body = body.decode("utf-8")[:1000]  # Limit body size
            except Exception:
                request_body = "<unable to read body>"
        
        # Log request
        logger.info(
            f"Incoming request: {request.method} {request.url.path}",
            extra={
                "request_id": request_id,
                "method": request.method,
                "url": str(request.url),
                "path": request.url.path,
                "query_params": dict(request.query_params),
                "headers": dict(request.headers),
                "client_ip": client_ip,
                "user_agent": user_agent,
                "request_body": request_body,
                "app": "test_static_schemas",
                "model": "TestStaticSchema",
                "event_type": "request_start"
            }
        )

    async def _log_response(
        self, 
        request: Request, 
        response: Response, 
        request_id: str, 
        response_time_ms: float
    ) -> None:
        """
        Log outgoing response details.
        
        Args:
            request: HTTP request object
            response: HTTP response object
            request_id: Unique request identifier
            response_time_ms: Response time in milliseconds
        """
        # Get response body if enabled
        response_body = None
        if self.log_body and hasattr(response, 'body'):
            try:
                if response.body:
                    response_body = response.body.decode("utf-8")[:1000]  # Limit body size
            except Exception:
                response_body = "<unable to read body>"
        
        # Determine log level based on status code
        log_level = "info"
        if response.status_code >= 400:
            log_level = "warning"
        if response.status_code >= 500:
            log_level = "error"
        
        # Log response
        log_method = getattr(logger, log_level)
        log_method(
            f"Response: {response.status_code} for {request.method} {request.url.path}",
            extra={
                "request_id": request_id,
                "method": request.method,
                "url": str(request.url),
                "path": request.url.path,
                "status_code": response.status_code,
                "response_time_ms": response_time_ms,
                "response_headers": dict(response.headers),
                "response_body": response_body,
                "app": "test_static_schemas",
                "model": "TestStaticSchema",
                "event_type": "request_complete"
            }
        )

    def _get_client_ip(self, request: Request) -> str:
        """
        Extract client IP address from request.
        
        Args:
            request: HTTP request object
            
        Returns:
            Client IP address
        """
        # Check for forwarded headers (common in production)
        forwarded_for = request.headers.get("X-Forwarded-For")
        if forwarded_for:
            return forwarded_for.split(",")[0].strip()
        
        real_ip = request.headers.get("X-Real-IP")
        if real_ip:
            return real_ip
        
        # Fallback to direct client
        if request.client:
            return request.client.host
        
        return "unknown" 