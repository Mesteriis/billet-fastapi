"""
TestModernSyntax Pydantic schemas for Enterprise level.

This file was auto-generated by Autogen CLI.
Application: test_modern_syntax
Level: Enterprise
Generated at: 2025-06-22T17:39:23.618527
Template Version: v1.0.0 (Complete)
"""

from typing import Any, Literal
from uuid import UUID
from datetime import datetime

from pydantic import BaseModel, Field, ConfigDict, create_model, field_validator
from core.base.models import BaseSchema

from apps.test_modern_syntax.models.test_modern_syntax_models import TestModernSyntax


def create_enterprise_schemas_from_model(model_class: type) -> tuple[type, type, type, type]:
    """
    Dynamically create Enterprise Pydantic schemas from SQLAlchemy model.
    
    Args:
        model_class: SQLAlchemy model class
        
    Returns:
        Tuple of (Base, Create, Update, Response) schema classes
    """
    # Get model columns (excluding base fields that are in BaseSchema)
    base_columns = {'id', 'created_at', 'updated_at', 'deleted_at'}
    model_columns = {}
    
    for column in model_class.__table__.columns:
        if column.name not in base_columns:
            # Determine Python type from SQLAlchemy column
            python_type = column.type.python_type
            nullable = column.nullable
            
            # Make type optional if nullable
            if nullable:
                python_type = python_type | None
                
            model_columns[column.name] = (python_type, ...)
    
    # Create Base schema with common fields
    TestModernSyntaxBase = create_model(
        'TestModernSyntaxBase',
        __base__=BaseModel,
        **model_columns
    )
    
    # Create schema with all fields optional for updates
    update_columns = {}
    for name, (field_type, _) in model_columns.items():
        # Make all fields optional for update
        if hasattr(field_type, '__origin__') and field_type.__origin__ is type(int | None).__origin__:
            # Already optional
            update_columns[name] = (field_type, None)
        else:
            # Make optional
            update_columns[name] = (field_type | None, None)
    
    TestModernSyntaxUpdate = create_model(
        'TestModernSyntaxUpdate',
        __base__=BaseModel,
        **update_columns
    )
    
    # Create schema inheriting from BaseSchema for responses
    response_columns = {
        name: (field_type, ...)
        for name, (field_type, _) in model_columns.items()
    }
    
    # Add Enterprise-specific computed fields
    response_columns.update({
        'cache_status': (str | None, None),
        'tenant_info': (dict[str, Any] | None, None),
        'performance_metrics': (dict[str, float] | None, None),
        'event_metadata': (dict[str, Any] | None, None),
    })
    
    TestModernSyntaxResponse = create_model(
        'TestModernSyntaxResponse',
        __base__=BaseSchema,
        __config__=ConfigDict(from_attributes=True),
        **response_columns
    )
    
    # Create schema inheriting from base for creation
    TestModernSyntaxCreate = create_model(
        'TestModernSyntaxCreate',
        __base__=TestModernSyntaxBase,
        **{name: (field_type, ...) for name, (field_type, _) in model_columns.items() if not name.endswith('_at')}
    )
    
    return TestModernSyntaxBase, TestModernSyntaxCreate, TestModernSyntaxUpdate, TestModernSyntaxResponse


# Create schemas dynamically from model
TestModernSyntaxBase, TestModernSyntaxCreate, TestModernSyntaxUpdate, TestModernSyntaxResponse = create_enterprise_schemas_from_model(TestModernSyntax)


class TestModernSyntaxList(BaseModel):
    """Schema for paginated TestModernSyntax list responses (Enterprise level)."""
    
    items: list[TestModernSyntaxResponse] = Field(default_factory=list, description="List of testmodernsyntaxs")
    total: int = Field(default=0, ge=0, description="Total number of testmodernsyntaxs matching filters")
    
    
    page: int = Field(default=1, ge=1, description="Current page number")
    size: int = Field(default=20, ge=1, le=100, description="Number of items per page")
    pages: int = Field(default=1, ge=0, description="Total number of pages")
    

    # Enterprise-specific metadata
    filters_applied: dict[str, Any] = Field(default_factory=dict, description="Applied filters summary")
    facets: dict[str, dict[str, int]] | None = Field(default=None, description="Faceted search results")
    search_time_ms: float | None = Field(default=None, description="Search execution time in milliseconds")
    cache_hit_ratio: float | None = Field(default=None, description="Cache hit ratio for this query")
    tenant_id: UUID | None = Field(default=None, description="Tenant identifier")


class TestModernSyntaxSearchRequest(BaseModel):
    """Schema for Enterprise-level search requests."""
    
    query: str | None = Field(default=None, max_length=500, description="Full-text search query")
    search_fields: list[str] | None = Field(default=None, description="Fields to search in")
    sort_by: str = Field(default="created_at", description="Sort field")
    sort_order: Literal["asc", "desc"] = Field(default="desc", description="Sort order")
    page: int = Field(default=1, ge=1, description="Page number")
    size: int = Field(default=20, ge=1, le=100, description="Items per page")
    
    # Enterprise features
    include_facets: bool = Field(default=False, description="Include faceted search results")
    include_aggregations: bool = Field(default=False, description="Include aggregation results")
    include_performance_metrics: bool = Field(default=False, description="Include performance metrics")
    tenant_id: UUID | None = Field(default=None, description="Tenant identifier for multi-tenancy")
    use_cache: bool = Field(default=True, description="Whether to use cache for this query")


class TestModernSyntaxFilter(BaseModel):
    """Schema for filtering TestModernSyntax queries (Enterprise level)."""
    
    # Base filters
    id: UUID | None = None
    created_at__gte: datetime | None = None
    created_at__lte: datetime | None = None
    updated_at__gte: datetime | None = None
    updated_at__lte: datetime | None = None
    deleted_at__isnull: bool | None = None
    
    # Enterprise-specific filters
    tenant_id: UUID | None = None
    search_query: str | None = None
    search_fields: list[str] | None = None
    
    model_config = ConfigDict(extra='allow')


class TestModernSyntaxEventLog(BaseModel):
    """Schema for event logging."""
    
    event_id: UUID = Field(..., description="Event identifier")
    event_type: str = Field(..., description="Type of event")
    entity_id: UUID = Field(..., description="Entity identifier")
    tenant_id: UUID | None = Field(default=None, description="Tenant identifier")
    user_id: UUID | None = Field(default=None, description="User identifier")
    metadata: dict[str, Any] = Field(default_factory=dict, description="Event metadata")
    timestamp: datetime = Field(..., description="Event timestamp")


# Convenient type aliases
TestModernSyntaxCreateData = TestModernSyntaxCreate
TestModernSyntaxUpdateData = TestModernSyntaxUpdate
TestModernSyntaxResponseData = TestModernSyntaxResponse
TestModernSyntaxFilterData = TestModernSyntaxFilter
TestModernSyntaxSearchData = TestModernSyntaxSearchRequest
TestModernSyntaxEventData = TestModernSyntaxEventLog