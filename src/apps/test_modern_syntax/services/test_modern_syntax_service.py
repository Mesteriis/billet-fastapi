"""
TestModernSyntax service implementation for Advanced level.

This file was auto-generated by Autogen CLI.
Application: test_modern_syntax
Level: Enterprise
Generated at: 2025-06-22T17:39:23.618527
"""

from typing import Optional, Any
import logging
import json

from sqlalchemy.ext.asyncio import AsyncSession

from apps.test_modern_syntax.repo.test_modern_syntax_repo import TestModernSyntaxRepository
from apps.test_modern_syntax.schemas.test_modern_syntax_schemas import (
    TestModernSyntaxCreate,
    TestModernSyntaxUpdate,
    TestModernSyntaxResponse,
    TestModernSyntaxList,
    TestModernSyntaxSearchRequest,
    TestModernSyntaxStatus
)
from apps.test_modern_syntax.exceptions import (
    TestModernSyntaxServiceException,
    TestModernSyntaxValidationException,
    TestModernSyntaxAlreadyExistsError,
    TestModernSyntaxNotFoundError
)

logger = logging.getLogger("test_modern_syntax.testmodernsyntax")


class TestModernSyntaxService:
    """
    Advanced service layer for TestModernSyntax business logic.
    
    This service provides advanced business logic operations including:
    - Complex validation and business rules
    - Full-text search with relevance scoring
    - Advanced filtering and faceted search
    - Priority and status management
    - Tag-based categorization
    - Comprehensive error handling
    - Advanced soft delete operations
    
    Example:
        >>> async with async_session() as session:
        ...     service = TestModernSyntaxService(session)
        ...     
        ...     # Advanced search
        ...     search_request = TestModernSyntaxSearchRequest(
        ...         query="business critical",
        ...         priority_gte=5,
        ...         status=["active", "draft"],
        ...         include_facets=True
        ...     )
        ...     results = await service.search_testmodernsyntaxs(search_request)
    """

    def __init__(self, session: AsyncSession):
        """Initialize TestModernSyntax service."""
        self.session = session
        self.repository = TestModernSyntaxRepository(session)

    async def create_testmodernsyntax(self, create_data: TestModernSyntaxCreate) -> TestModernSyntaxResponse:
        """Create a new testmodernsyntax with advanced validation."""
        try:
            await self._validate_create_data(create_data)
            
            # Process tags
            processed_data = create_data.model_copy()
            if processed_data.tags:
                processed_data.tags = json.dumps(processed_data.tags)
            
            logger.info(f"Creating advanced testmodernsyntax: {create_data.name}")
            entity = await self.repository.create(processed_data)
            
            return await self._build_response(entity)
            
        except (TestModernSyntaxValidationException, TestModernSyntaxAlreadyExistsError):
            raise
        except Exception as e:
            logger.error(f"Failed to create testmodernsyntax: {e}")
            raise TestModernSyntaxServiceException(
                f"Failed to create testmodernsyntax: {str(e)}",
                operation="create_testmodernsyntax"
            ) from e

    async def get_testmodernsyntax(self, testmodernsyntax_id: int) -> Optional[TestModernSyntaxResponse]:
        """
        Get testmodernsyntax by ID with computed fields.
        
        Args:
            testmodernsyntax_id: ID of the testmodernsyntax to retrieve
            
        Returns:
            TestModernSyntax response with computed fields if found, None otherwise
            
        Raises:
            TestModernSyntaxServiceException: If retrieval fails
            
        Example:
            >>> testmodernsyntax = await service.get_testmodernsyntax(123)
            >>> if testmodernsyntax:
            ...     print(f"Found: {testmodernsyntax.name} (Priority: {testmodernsyntax.priority})")
        """
        try:
            logger.debug(f"Getting testmodernsyntax with ID: {testmodernsyntax_id}")
            entity = await self.repository.get(testmodernsyntax_id)
            
            if entity:
                return await self._build_response(entity)
            return None
            
        except Exception as e:
            logger.error(f"Failed to get testmodernsyntax {testmodernsyntax_id}: {e}")
            raise TestModernSyntaxServiceException(
                f"Failed to retrieve testmodernsyntax: {str(e)}",
                operation="get_testmodernsyntax"
            ) from e

    async def update_testmodernsyntax(
        self, 
        testmodernsyntax_id: int, 
        update_data: TestModernSyntaxUpdate
    ) -> Optional[TestModernSyntaxResponse]:
        """
        Update testmodernsyntax with advanced business validation.
        
        Args:
            testmodernsyntax_id: ID of the testmodernsyntax to update
            update_data: Data for updating the testmodernsyntax
            
        Returns:
            Updated testmodernsyntax response if found
            
        Raises:
            TestModernSyntaxValidationException: If validation fails
            TestModernSyntaxNotFoundError: If testmodernsyntax not found
            TestModernSyntaxServiceException: If update fails
            
        Example:
            >>> data = TestModernSyntaxUpdate(
            ...     name="Updated Name",
            ...     priority=9,
            ...     tags=["updated", "high-priority"]
            ... )
            >>> updated = await service.update_testmodernsyntax(123, data)
        """
        try:
            # Check if entity exists
            existing = await self.repository.get(testmodernsyntax_id)
            if not existing:
                raise TestModernSyntaxNotFoundError(
                    f"TestModernSyntax with ID {testmodernsyntax_id} not found",
                    entity_id=testmodernsyntax_id
                )
            
            # Advanced business validation
            await self._validate_update_data(update_data, testmodernsyntax_id)
            
            # Process tags if provided
            processed_data = update_data.model_copy()
            if processed_data.tags is not None:
                processed_data.tags = json.dumps(processed_data.tags) if processed_data.tags else None
            
            # Update entity
            logger.info(f"Updating testmodernsyntax {testmodernsyntax_id}")
            entity = await self.repository.update(testmodernsyntax_id, processed_data)
            
            if entity:
                response = await self._build_response(entity)
                logger.info(f"Updated testmodernsyntax {testmodernsyntax_id}")
                return response
            return None
            
        except (TestModernSyntaxValidationException, TestModernSyntaxNotFoundError):
            raise
        except Exception as e:
            logger.error(f"Failed to update testmodernsyntax {testmodernsyntax_id}: {e}")
            raise TestModernSyntaxServiceException(
                f"Failed to update testmodernsyntax: {str(e)}",
                operation="update_testmodernsyntax"
            ) from e

    async def delete_testmodernsyntax(self, testmodernsyntax_id: int) -> bool:
        """
        Delete testmodernsyntax by ID (soft delete if enabled).
        
        Args:
            testmodernsyntax_id: ID of the testmodernsyntax to delete
            
        Returns:
            True if deleted successfully, False if not found
            
        Raises:
            TestModernSyntaxServiceException: If deletion fails
            
        Example:
            >>> success = await service.delete_testmodernsyntax(123)
            >>> if success:
            ...     print("TestModernSyntax deleted successfully")
        """
        try:
            logger.info(f"Deleting testmodernsyntax {testmodernsyntax_id}")
            success = await self.repository.remove(testmodernsyntax_id)
            
            if success:
                logger.info(f"Deleted testmodernsyntax {testmodernsyntax_id}")
            else:
                logger.warning(f"TestModernSyntax {testmodernsyntax_id} not found for deletion")
                
            return success
            
        except Exception as e:
            logger.error(f"Failed to delete testmodernsyntax {testmodernsyntax_id}: {e}")
            raise TestModernSyntaxServiceException(
                f"Failed to delete testmodernsyntax: {str(e)}",
                operation="delete_testmodernsyntax"
            ) from e

    async def search_testmodernsyntaxs(self, search_request: TestModernSyntaxSearchRequest) -> TestModernSyntaxList:
        """Advanced search with complex filtering."""
        try:
            logger.debug(f"Advanced search testmodernsyntaxs")
            return await self.repository.complex_search(search_request)
        except Exception as e:
            logger.error(f"Failed to search testmodernsyntaxs: {e}")
            raise TestModernSyntaxServiceException(
                f"Failed to search testmodernsyntaxs: {str(e)}",
                operation="search_testmodernsyntaxs"
            ) from e

    async def get_testmodernsyntax_by_name(self, name: str, status: Optional[TestModernSyntaxStatus] = None) -> Optional[TestModernSyntaxResponse]:
        """
        Get testmodernsyntax by name with optional status filter.
        
        Args:
            name: Name to search for
            status: Optional status filter
            
        Returns:
            TestModernSyntax response if found
            
        Example:
            >>> testmodernsyntax = await service.get_testmodernsyntax_by_name("Project Alpha", "active")
        """
        try:
            entity = await self.repository.get_by_name_and_status(
                name, status or TestModernSyntaxStatus.ACTIVE
            )
            if entity:
                return await self._build_response(entity)
            return None
        except Exception as e:
            logger.error(f"Failed to get testmodernsyntax by name '{name}': {e}")
            raise TestModernSyntaxServiceException(
                f"Failed to get testmodernsyntax by name: {str(e)}",
                operation="get_testmodernsyntax_by_name"
            ) from e

    async def update_priority(self, testmodernsyntax_id: int, priority: int) -> Optional[TestModernSyntaxResponse]:
        """
        Update testmodernsyntax priority with validation.
        
        Args:
            testmodernsyntax_id: ID of the testmodernsyntax to update
            priority: New priority (0-10)
            
        Returns:
            Updated testmodernsyntax response
            
        Raises:
            TestModernSyntaxValidationException: If priority is invalid
            
        Example:
            >>> updated = await service.update_priority(123, 9)
        """
        if not (0 <= priority <= 10):
            raise TestModernSyntaxValidationException(
                "Priority must be between 0 and 10",
                validation_errors=[{"field": "priority", "message": "Invalid priority range"}]
            )
        
        update_data = TestModernSyntaxUpdate(priority=priority)
        return await self.update_testmodernsyntax(testmodernsyntax_id, update_data)

    async def add_tags(self, testmodernsyntax_id: int, tags: list[str]) -> Optional[TestModernSyntaxResponse]:
        """
        Add tags to testmodernsyntax.
        
        Args:
            testmodernsyntax_id: ID of the testmodernsyntax
            tags: List of tags to add
            
        Returns:
            Updated testmodernsyntax response
            
        Example:
            >>> updated = await service.add_tags(123, ["urgent", "customer"])
        """
        entity = await self.repository.get(testmodernsyntax_id)
        if not entity:
            raise TestModernSyntaxNotFoundError(f"TestModernSyntax with ID {testmodernsyntax_id} not found")
        
        # Merge with existing tags
        existing_tags = set(entity.tags_list)
        new_tags = list(existing_tags.union(set(tags)))
        
        update_data = TestModernSyntaxUpdate(tags=new_tags)
        return await self.update_testmodernsyntax(testmodernsyntax_id, update_data)

    async def get_statistics(self) -> dict[str, Any]:
        """
        Get comprehensive statistics about testmodernsyntaxs.
        
        Returns:
            Dictionary with various statistics
            
        Example:
            >>> stats = await service.get_statistics()
            >>> print(f"Total active: {stats['total_active']}")
        """
        try:
            # Get basic counts
            total_count = await self.repository.count()
            active_count = await self.repository.count(filters={"status": "active", "is_deleted": False})
            
            # Get priority stats
            priority_stats = await self.repository.get_priority_stats()
            
            # Get status counts
            status_counts = await self.repository.get_status_counts()
            
            return {
                "total_count": total_count,
                "active_count": active_count,
                "priority_stats": priority_stats,
                "status_counts": status_counts,
                "high_priority_count": len(await self.repository.get_by_priority_range(7, 10))
            }
            
        except Exception as e:
            logger.error(f"Failed to get statistics: {e}")
            raise TestModernSyntaxServiceException(
                f"Failed to get statistics: {str(e)}",
                operation="get_statistics"
            ) from e

    # Private helper methods

    async def _build_response(self, entity) -> TestModernSyntaxResponse:
        """Build response object with computed fields."""
        response = TestModernSyntaxResponse.model_validate(entity)
        response.tags_count = len(entity.tags_list) if entity.tags else 0
        response.is_high_priority = entity.priority >= 7
        return response

    async def _validate_create_data(self, create_data: TestModernSyntaxCreate) -> None:
        """Advanced validation for create data."""
        # Check business rules
        if create_data.priority > 8 and create_data.status != TestModernSyntaxStatus.ACTIVE:
            raise TestModernSyntaxValidationException(
                "High priority testmodernsyntaxs (>8) must be active",
                validation_errors=[{"field": "status", "message": "High priority items must be active"}]
            )

    async def _validate_update_data(self, update_data: TestModernSyntaxUpdate, testmodernsyntax_id: int) -> None:
        """Advanced validation for update data."""
        # Check if name already exists (excluding current entity)
        if update_data.name:
            existing = await self.repository.get_by_name_and_status(
                update_data.name, 
                update_data.status or TestModernSyntaxStatus.ACTIVE
            )
            if existing and existing.id != testmodernsyntax_id:
                raise TestModernSyntaxValidationException(
                    f"TestModernSyntax with name '{update_data.name}' already exists",
                    validation_errors=[{"field": "name", "message": "Name already exists"}]
                )
        
        # Validate business rules
        if update_data.priority and update_data.priority > 8:
            if update_data.status and update_data.status != TestModernSyntaxStatus.ACTIVE:
                raise TestModernSyntaxValidationException(
                    "High priority testmodernsyntaxs (>8) must be active",
                    validation_errors=[{"field": "status", "message": "High priority items must be active"}]
                ) 