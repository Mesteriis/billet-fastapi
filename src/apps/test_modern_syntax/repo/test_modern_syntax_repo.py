"""
TestModernSyntax repository implementation for Advanced level.

This file was auto-generated by Autogen CLI.
Application: test_modern_syntax
Level: Enterprise
Generated at: 2025-06-22T17:39:23.618527
"""

from typing import Optional, Any
from datetime import datetime
import time

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import and_, or_, func, text

from core.base.repo import EnterpriseRepository
from apps.test_modern_syntax.models.test_modern_syntax_models import TestModernSyntax
from apps.test_modern_syntax.schemas.test_modern_syntax_schemas import (
    TestModernSyntaxCreate,
    TestModernSyntaxUpdate,
    TestModernSyntaxResponse,
    TestModernSyntaxList,
    TestModernSyntaxSearchRequest,
    TestModernSyntaxStatus
)


class TestModernSyntaxRepository(EnterpriseRepository[TestModernSyntax, TestModernSyntaxCreate, TestModernSyntaxUpdate]):
    """
    Repository for TestModernSyntax entities with enterprise functionality.
    
    This repository provides enterprise-grade CRUD functionality using EnterpriseRepository
    which includes:
    - Basic CRUD operations (create, get, update, remove, restore, list, count)
    - 40+ filter operators (eq, ne, lt, lte, gt, gte, like, ilike, in, between, etc.)
    - Full-text search capabilities (PostgreSQL)
    - Cursor pagination for large datasets
    - Complex filters with AND/OR/NOT logic
    - Aggregation functions (SUM, AVG, MAX, MIN, COUNT, GROUP BY)
    - JOIN operations through filters
    - Redis caching for performance
    - Event publishing for data changes
    - Monitoring and metrics collection
    - Distributed transaction support
    - Soft delete support
    - Pagination support
    
    Example:
        >>> async with async_session() as session:
        ...     repo = TestModernSyntaxRepository(session)
        ...     
        ...     # Advanced search with multiple filters
        ...     results = await repo.advanced_search({
        ...         "name__ilike": "%project%",
        ...         "priority__gte": 5,
        ...         "status__in": ["active", "draft"],
        ...         "tags__contains": "important"
        ...     })
        ...     
        ...     # Full-text search
        ...     results = await repo.search("business critical project")
        ...     
        ...     # Aggregations
        ...     stats = await repo.get_priority_stats()
        ...     
        ...     # Complex filtering
        ...     advanced_results = await repo.complex_search(search_request)
    """

    def __init__(self, session: AsyncSession):
        """
        Initialize TestModernSyntax repository.
        
        Args:
            session: Database session for operations
        """
        super().__init__(model=TestModernSyntax, session=session)

    async def get_by_name_and_status(
        self, 
        name: str, 
        status: TestModernSyntaxStatus = TestModernSyntaxStatus.ACTIVE
    ) -> Optional[TestModernSyntax]:
        """
        Get testmodernsyntax by name and status.
        
        Args:
            name: The name to search for
            status: The status to filter by
            
        Returns:
            TestModernSyntax instance if found, None otherwise
            
        Example:
            >>> testmodernsyntax = await repo.get_by_name_and_status("Project Alpha", "active")
        """
        return await self.get_by_filters({
            "name": name,
            "status": status.value,
            
            "is_deleted": False
            
        })

    async def search_by_text(
        self, 
        query: str,
        page: int = 1,
        size: int = 20,
        include_facets: bool = False
    ) -> TestModernSyntaxList:
        """
        Perform full-text search across name, description, and tags.
        
        Args:
            query: Search query string
            page: Page number (1-based)
            size: Number of items per page
            include_facets: Whether to include faceted search results
            
        Returns:
            TestModernSyntaxList with search results and metadata
            
        Example:
            >>> result = await repo.search_by_text("important business project")
            >>> print(f"Found {result.total} results in {result.search_time_ms}ms")
        """
        start_time = time.time()
        
        # Build search filters
        search_filters = {}
        if query:
            # Use full-text search if available, otherwise use ILIKE
            search_filters = {
                "OR": [
                    {"name__ilike": f"%{query}%"},
                    {"description__ilike": f"%{query}%"},
                    {"tags__ilike": f"%{query}%"}
                ]
            }
        
        # Add default filters
        active_filters = search_filters.copy()
        
        active_filters["is_deleted"] = False
        
        
        # Get paginated results using advanced search
        items, total = await self.search(
            filters=active_filters,
            page=page,
            size=size,
            sort_by="priority",
            sort_order="desc"
        )
        
        # Calculate pagination metadata
        pages = (total + size - 1) // size
        search_time = (time.time() - start_time) * 1000  # Convert to milliseconds
        
        # Convert to response objects with computed fields
        response_items = []
        for item in items:
            response_data = TestModernSyntaxResponse.model_validate(item)
            
            # Add computed fields
            response_data.tags_count = len(item.tags_list) if item.tags else 0
            response_data.is_high_priority = item.priority >= 7
            
            # Calculate search relevance (simplified)
            if query:
                relevance = 0.0
                query_lower = query.lower()
                if query_lower in item.name.lower():
                    relevance += 0.5
                if item.description and query_lower in item.description.lower():
                    relevance += 0.3
                if any(query_lower in tag.lower() for tag in item.tags_list):
                    relevance += 0.2
                response_data.search_relevance = min(relevance, 1.0)
            
            response_items.append(response_data)
        
        # Build facets if requested
        facets = None
        if include_facets:
            facets = await self._build_facets(active_filters)
        
        return TestModernSyntaxList(
            items=response_items,
            total=total,
            
            page=page,
            size=size,
            pages=pages,
            
            filters_applied=active_filters,
            facets=facets,
            search_time_ms=round(search_time, 2)
        )

    async def complex_search(self, search_request: TestModernSyntaxSearchRequest) -> TestModernSyntaxList:
        """
        Perform complex search with multiple filters and sorting.
        
        Args:
            search_request: Complex search request with filters and options
            
        Returns:
            TestModernSyntaxList with filtered and sorted results
            
        Example:
            >>> request = TestModernSyntaxSearchRequest(
            ...     query="important",
            ...     status=["active", "draft"],
            ...     priority_gte=5,
            ...     sort_by="priority",
            ...     sort_order="desc"
            ... )
            >>> result = await repo.complex_search(request)
        """
        start_time = time.time()
        
        # Build complex filters
        filters = {}
        
        # Text search
        if search_request.query:
            filters["OR"] = [
                {"name__ilike": f"%{search_request.query}%"},
                {"description__ilike": f"%{search_request.query}%"},
                {"tags__ilike": f"%{search_request.query}%"}
            ]
        
        # Status filter
        if search_request.status:
            status_values = [status.value for status in search_request.status]
            filters["status__in"] = status_values
        
        # Priority filters
        if search_request.priority_gte is not None:
            filters["priority__gte"] = search_request.priority_gte
        
        if search_request.priority_lte is not None:
            filters["priority__lte"] = search_request.priority_lte
        
        # Tags filter
        if search_request.tags:
            # OR logic for tags
            tag_filters = []
            for tag in search_request.tags:
                tag_filters.append({"tags__ilike": f"%{tag}%"})
            if tag_filters:
                if "OR" in filters:
                    filters["AND"] = [{"OR": filters["OR"]}, {"OR": tag_filters}]
                else:
                    filters["OR"] = tag_filters
        
        # Date filters
        if search_request.created_after:
            filters["created_at__gte"] = search_request.created_after
        
        if search_request.created_before:
            filters["created_at__lte"] = search_request.created_before
        
        # Default filters
        
        filters["is_deleted"] = False
        
        
        # Perform search with sorting
        items, total = await self.search(
            filters=filters,
            page=search_request.page,
            size=search_request.size,
            sort_by=search_request.sort_by,
            sort_order=search_request.sort_order
        )
        
        # Calculate pagination metadata
        pages = (total + search_request.size - 1) // search_request.size
        search_time = (time.time() - start_time) * 1000
        
        # Convert to response objects
        response_items = []
        for item in items:
            response_data = TestModernSyntaxResponse.model_validate(item)
            response_data.tags_count = len(item.tags_list) if item.tags else 0
            response_data.is_high_priority = item.priority >= 7
            response_items.append(response_data)
        
        # Build facets if requested
        facets = None
        if search_request.include_facets:
            facets = await self._build_facets(filters)
        
        return TestModernSyntaxList(
            items=response_items,
            total=total,
            
            page=search_request.page,
            size=search_request.size,
            pages=pages,
            
            filters_applied=filters,
            facets=facets,
            search_time_ms=round(search_time, 2)
        )

    async def get_by_priority_range(
        self, 
        min_priority: int = 0, 
        max_priority: int = 10,
        status: Optional[TestModernSyntaxStatus] = None
    ) -> list[TestModernSyntax]:
        """
        Get testmodernsyntaxs within priority range.
        
        Args:
            min_priority: Minimum priority level
            max_priority: Maximum priority level
            status: Optional status filter
            
        Returns:
            List of TestModernSyntax instances
            
        Example:
            >>> high_priority = await repo.get_by_priority_range(7, 10, "active")
        """
        filters = {
            "priority__gte": min_priority,
            "priority__lte": max_priority,
            
            "is_deleted": False
            
        }
        
        if status:
            filters["status"] = status.value
        
        items, _ = await self.list(filters=filters, sort_by="priority", sort_order="desc")
        return items

    async def get_priority_stats(self) -> dict[str, Any]:
        """
        Get priority statistics using aggregation.
        
        Returns:
            Dictionary with priority statistics
            
        Example:
            >>> stats = await repo.get_priority_stats()
            >>> print(f"Average priority: {stats['avg_priority']}")
        """
        return await self.aggregate(
            fields=["priority"],
            operations=["avg", "min", "max", "count"],
            filters={"is_deleted": False}
        )

    async def get_status_counts(self) -> dict[str, int]:
        """
        Get count of testmodernsyntaxs by status.
        
        Returns:
            Dictionary mapping status to count
            
        Example:
            >>> counts = await repo.get_status_counts()
            >>> print(f"Active: {counts.get('active', 0)}")
        """
        result = await self.aggregate(
            fields=["status"],
            operations=["count"],
            group_by=["status"],
            filters={"is_deleted": False}
        )
        
        return {item["status"]: item["count"] for item in result}

    async def bulk_update_status(
        self, 
        entity_ids: list[int], 
        new_status: TestModernSyntaxStatus
    ) -> int:
        """
        Bulk update status for multiple testmodernsyntaxs.
        
        Args:
            entity_ids: List of entity IDs to update
            new_status: New status to set
            
        Returns:
            Number of updated entities
            
        Example:
            >>> count = await repo.bulk_update_status([1, 2, 3], "archived")
            >>> print(f"Updated {count} testmodernsyntaxs")
        """
        return await self.bulk_update(
            filters={"id__in": entity_ids},
            update_data={"status": new_status.value}
        )

    async def _build_facets(self, filters: dict) -> dict[str, dict[str, int]]:
        """
        Build faceted search results.
        
        Args:
            filters: Base filters to apply
            
        Returns:
            Dictionary with faceted counts
        """
        facets = {}
        
        # Status facets
        status_counts = await self.aggregate(
            fields=["status"],
            operations=["count"],
            group_by=["status"],
            filters=filters
        )
        facets["status"] = {item["status"]: item["count"] for item in status_counts}
        
        return facets

    
    async def soft_delete_by_status(self, status: TestModernSyntaxStatus) -> int:
        """
        Soft delete all testmodernsyntaxs with given status.
        
        Args:
            status: Status to filter by
            
        Returns:
            Number of soft deleted entities
            
        Example:
            >>> count = await repo.soft_delete_by_status("archived")
        """
        return await self.bulk_update(
            filters={"status": status.value, "is_deleted": False},
            update_data={"is_deleted": True, "status": "deleted"}
        )
     