"""
TestProduct service implementation.

This file was auto-generated by Autogen CLI.
Application: test_products
Level: BasicCRUD
Generated at: 2025-06-22T15:53:05.029679
"""

from typing import Optional
import logging

from sqlalchemy.ext.asyncio import AsyncSession

from apps.test_products.repo.test_products_repo import TestProductRepository
from apps.test_products.schemas.test_products_schemas import (
    TestProductCreate,
    TestProductUpdate,
    TestProductResponse,
    TestProductList
)
from apps.test_products.exceptions import (
    TestProductServiceException,
    TestProductValidationException
)

logger = logging.getLogger("test_products.testproduct")


class TestProductService:
    """
    Service layer for TestProduct business logic.
    
    This service provides business logic operations for TestProduct entities,
    including validation, error handling, and coordination between different
    components.
    
    Features:
    - Business logic validation
    - Exception handling with detailed context
    - Logging of operations
    - Soft delete operations
    - Comprehensive error messages
    
    Example:
        >>> async with async_session() as session:
        ...     service = TestProductService(session)
        ...     
        ...     # Create with validation
        ...     create_data = TestProductCreate(name="Business TestProduct")
        ...     testproduct = await service.create_testproduct(create_data)
        ...     
        ...     # Get with error handling
        ...     found = await service.get_testproduct(testproduct.id)
        ...     
        ...     # List with business filters
        ...     result = await service.list_testproducts(page=1, size=10)
    """

    def __init__(self, session: AsyncSession):
        """
        Initialize TestProduct service.
        
        Args:
            session: Database session for operations
        """
        self.session = session
        self.repository = TestProductRepository(session)

    async def create_testproduct(self, create_data: TestProductCreate) -> TestProductResponse:
        """
        Create a new testproduct with business validation.
        
        Args:
            create_data: Data for creating the testproduct
            
        Returns:
            Created testproduct response
            
        Raises:
            TestProductValidationException: If validation fails
            TestProductServiceException: If creation fails
            
        Example:
            >>> data = TestProductCreate(name="New TestProduct")
            >>> testproduct = await service.create_testproduct(data)
        """
        try:
            # Business validation
            await self._validate_create_data(create_data)
            
            # Create entity
            logger.info(f"Creating testproduct: {create_data.name}")
            entity = await self.repository.create(create_data)
            
            # Convert to response
            response = TestProductResponse.model_validate(entity)
            logger.info(f"Created testproduct with ID: {response.id}")
            
            return response
            
        except TestProductValidationException:
            # Re-raise validation exceptions
            raise
        except Exception as e:
            logger.error(f"Failed to create testproduct: {e}")
            raise TestProductServiceException(
                f"Failed to create testproduct: {str(e)}",
                operation="create_testproduct"
            ) from e

    async def get_testproduct(self, testproduct_id: int) -> Optional[TestProductResponse]:
        """
        Get testproduct by ID with error handling.
        
        Args:
            testproduct_id: ID of the testproduct to retrieve
            
        Returns:
            TestProduct response if found, None otherwise
            
        Raises:
            TestProductServiceException: If retrieval fails
            
        Example:
            >>> testproduct = await service.get_testproduct(123)
            >>> if testproduct:
            ...     print(f"Found: {testproduct.name}")
        """
        try:
            logger.debug(f"Getting testproduct with ID: {testproduct_id}")
            entity = await self.repository.get(testproduct_id)
            
            if entity:
                return TestProductResponse.model_validate(entity)
            return None
            
        except Exception as e:
            logger.error(f"Failed to get testproduct {testproduct_id}: {e}")
            raise TestProductServiceException(
                f"Failed to retrieve testproduct: {str(e)}",
                operation="get_testproduct"
            ) from e

    async def update_testproduct(
        self, 
        testproduct_id: int, 
        update_data: TestProductUpdate
    ) -> Optional[TestProductResponse]:
        """
        Update testproduct with business validation.
        
        Args:
            testproduct_id: ID of the testproduct to update
            update_data: Data for updating the testproduct
            
        Returns:
            Updated testproduct response if found
            
        Raises:
            TestProductValidationException: If validation fails
            TestProductServiceException: If update fails
            
        Example:
            >>> data = TestProductUpdate(name="Updated Name")
            >>> updated = await service.update_testproduct(123, data)
        """
        try:
            # Business validation
            await self._validate_update_data(update_data, testproduct_id)
            
            # Update entity
            logger.info(f"Updating testproduct {testproduct_id}")
            entity = await self.repository.update(testproduct_id, update_data)
            
            if entity:
                response = TestProductResponse.model_validate(entity)
                logger.info(f"Updated testproduct {testproduct_id}")
                return response
            return None
            
        except TestProductValidationException:
            raise
        except Exception as e:
            logger.error(f"Failed to update testproduct {testproduct_id}: {e}")
            raise TestProductServiceException(
                f"Failed to update testproduct: {str(e)}",
                operation="update_testproduct"
            ) from e

    async def delete_testproduct(self, testproduct_id: int) -> bool:
        """
        Delete testproduct by ID.
        
        Args:
            testproduct_id: ID of the testproduct to delete
            
        Returns:
            True if deleted successfully, False if not found
            
        Raises:
            TestProductServiceException: If deletion fails
            
        Example:
            >>> success = await service.delete_testproduct(123)
            >>> if success:
            ...     print("TestProduct deleted successfully")
        """
        try:
            logger.info(f"Deleting testproduct {testproduct_id}")
            success = await self.repository.remove(testproduct_id)
            
            if success:
                logger.info(f"Deleted testproduct {testproduct_id}")
            else:
                logger.warning(f"TestProduct {testproduct_id} not found for deletion")
                
            return success
            
        except Exception as e:
            logger.error(f"Failed to delete testproduct {testproduct_id}: {e}")
            raise TestProductServiceException(
                f"Failed to delete testproduct: {str(e)}",
                operation="delete_testproduct"
            ) from e

    async def list_testproducts(
        self,
        page: int = 1,
        size: int = 10,
        name_filter: Optional[str] = None
    ) -> TestProductList:
        """
        List testproducts with pagination and filtering.
        
        Args:
            page: Page number (1-based)
            size: Number of items per page
            name_filter: Optional name filter (partial match)
            
        Returns:
            Paginated list of testproducts
            
        Raises:
            TestProductServiceException: If listing fails
            
        Example:
            >>> result = await service.list_testproducts(
            ...     page=1, 
            ...     size=20, 
            ...     name_filter="test"
            ... )
            >>> print(f"Found {result.total} testproducts")
        """
        try:
            # Prepare filters
            filters = {}
            if name_filter:
                filters["name__ilike"] = f"%{name_filter}%"
            
            logger.debug(f"Listing testproducts: page={page}, size={size}, filters={filters}")
            result = await self.repository.list_active(
                page=page,
                size=size,
                filters=filters
            )
            
            logger.debug(f"Listed {len(result.items)} testproducts out of {result.total}")
            return result
            
        except Exception as e:
            logger.error(f"Failed to list testproducts: {e}")
            raise TestProductServiceException(
                f"Failed to list testproducts: {str(e)}",
                operation="list_testproducts"
            ) from e

    async def get_testproduct_by_name(self, name: str) -> Optional[TestProductResponse]:
        """
        Get testproduct by name.
        
        Args:
            name: Name to search for
            
        Returns:
            TestProduct response if found
            
        Example:
            >>> testproduct = await service.get_testproduct_by_name("Sample TestProduct")
        """
        try:
            entity = await self.repository.get_by_name(name)
            if entity:
                return TestProductResponse.model_validate(entity)
            return None
        except Exception as e:
            logger.error(f"Failed to get testproduct by name '{name}': {e}")
            raise TestProductServiceException(
                f"Failed to get testproduct by name: {str(e)}",
                operation="get_testproduct_by_name"
            ) from e

    # Private validation methods

    async def _validate_create_data(self, create_data: TestProductCreate) -> None:
        """Validate data for creating testproduct."""
        # Check if name already exists
        if await self.repository.exists_by_name(create_data.name):
            raise TestProductValidationException(
                f"TestProduct with name '{create_data.name}' already exists",
                validation_errors=[{"field": "name", "message": "Name already exists"}]
            )

    async def _validate_update_data(self, update_data: TestProductUpdate, testproduct_id: int) -> None:
        """Validate data for updating testproduct."""
        # Check if name already exists (excluding current entity)
        if update_data.name:
            existing = await self.repository.get_by_name(update_data.name)
            if existing and existing.id != testproduct_id:
                raise TestProductValidationException(
                    f"TestProduct with name '{update_data.name}' already exists",
                    validation_errors=[{"field": "name", "message": "Name already exists"}]
                ) 