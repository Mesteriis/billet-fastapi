"""
TestProduct API routes.

This file was auto-generated by Autogen CLI.
Application: test_products
Level: BasicCRUD
Generated at: 2025-06-22T15:53:05.029679
"""

from typing import Optional
import logging

from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession

from core.database import get_async_session
from apps.test_products.services.test_products_service import TestProductService
from apps.test_products.schemas.test_products_schemas import (
    TestProductCreate,
    TestProductUpdate,
    TestProductResponse,
    TestProductList
)
from apps.test_products.exceptions import (
    TestProductValidationException,
    TestProductServiceException
)

logger = logging.getLogger("api.test_products")

# Create router for TestProduct endpoints
router = APIRouter(prefix="/test-products", tags=['TestProduct'])


async def get_testproduct_service(
    session: AsyncSession = Depends(get_async_session)
) -> TestProductService:
    """
    Dependency to get TestProduct service instance.
    
    Args:
        session: Database session from dependency injection
        
    Returns:
        TestProductService instance
    """
    return TestProductService(session)


@router.post(
    "/",
    response_model=TestProductResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Create TestProduct",
    description="Create a new testproduct with the provided data.",
    responses={
        201: {"description": "TestProduct created successfully"},
        400: {"description": "Validation error"},
        409: {"description": "TestProduct already exists"},
        500: {"description": "Internal server error"}
    }
)
async def create_testproduct(
    create_data: TestProductCreate,
    service: TestProductService = Depends(get_testproduct_service)
) -> TestProductResponse:
    """
    Create a new testproduct.
    
    - **name**: TestProduct name (required, 1-255 characters)
    
    Returns the created testproduct with its assigned ID and metadata.
    
    Example request:
    ```json
    {
        "name": "Sample TestProduct"
    }
    ```
    """
    try:
        logger.info(f"API: Creating testproduct: {create_data.name}")
        result = await service.create_testproduct(create_data)
        logger.info(f"API: Created testproduct with ID: {result.id}")
        return result
        
    except TestProductValidationException as e:
        logger.warning(f"API: Validation error creating testproduct: {e}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail={"message": str(e), "errors": e.details.get("validation_errors", [])}
        )
    except TestProductServiceException as e:
        logger.error(f"API: Service error creating testproduct: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail={"message": "Failed to create testproduct", "error": str(e)}
        )


@router.get(
    "/{testproduct_id}",
    response_model=TestProductResponse,
    summary="Get TestProduct by ID",
    description="Retrieve a specific testproduct by its ID.",
    responses={
        200: {"description": "TestProduct found"},
        404: {"description": "TestProduct not found"},
        500: {"description": "Internal server error"}
    }
)
async def get_testproduct(
    testproduct_id: int,
    service: TestProductService = Depends(get_testproduct_service)
) -> TestProductResponse:
    """
    Get a testproduct by its ID.
    
    - **testproduct_id**: Unique identifier of the testproduct
    
    Returns the testproduct data if found.
    """
    try:
        logger.debug(f"API: Getting testproduct {testproduct_id}")
        result = await service.get_testproduct(testproduct_id)
        
        if not result:
            logger.warning(f"API: TestProduct {testproduct_id} not found")
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail={"message": f"TestProduct with ID {testproduct_id} not found"}
            )
        
        logger.debug(f"API: Found testproduct {testproduct_id}")
        return result
        
    except HTTPException:
        raise
    except TestProductServiceException as e:
        logger.error(f"API: Service error getting testproduct {testproduct_id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail={"message": "Failed to retrieve testproduct", "error": str(e)}
        )


@router.put(
    "/{testproduct_id}",
    response_model=TestProductResponse,
    summary="Update TestProduct",
    description="Update an existing testproduct with new data.",
    responses={
        200: {"description": "TestProduct updated successfully"},
        400: {"description": "Validation error"},
        404: {"description": "TestProduct not found"},
        409: {"description": "TestProduct name already exists"},
        500: {"description": "Internal server error"}
    }
)
async def update_testproduct(
    testproduct_id: int,
    update_data: TestProductUpdate,
    service: TestProductService = Depends(get_testproduct_service)
) -> TestProductResponse:
    """
    Update an existing testproduct.
    
    - **testproduct_id**: Unique identifier of the testproduct
    - **name**: New testproduct name (optional)
    
    Returns the updated testproduct data.
    
    Example request:
    ```json
    {
        "name": "Updated TestProduct Name"
    }
    ```
    """
    try:
        logger.info(f"API: Updating testproduct {testproduct_id}")
        result = await service.update_testproduct(testproduct_id, update_data)
        
        if not result:
            logger.warning(f"API: TestProduct {testproduct_id} not found for update")
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail={"message": f"TestProduct with ID {testproduct_id} not found"}
            )
        
        logger.info(f"API: Updated testproduct {testproduct_id}")
        return result
        
    except HTTPException:
        raise
    except TestProductValidationException as e:
        logger.warning(f"API: Validation error updating testproduct {testproduct_id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail={"message": str(e), "errors": e.details.get("validation_errors", [])}
        )
    except TestProductServiceException as e:
        logger.error(f"API: Service error updating testproduct {testproduct_id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail={"message": "Failed to update testproduct", "error": str(e)}
        )


@router.delete(
    "/{testproduct_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete TestProduct",
    description="Delete a testproduct by its ID.",
    responses={
        204: {"description": "TestProduct deleted successfully"},
        404: {"description": "TestProduct not found"},
        500: {"description": "Internal server error"}
    }
)
async def delete_testproduct(
    testproduct_id: int,
    service: TestProductService = Depends(get_testproduct_service)
) -> None:
    """
    Delete a testproduct by its ID.
    
    - **testproduct_id**: Unique identifier of the testproduct to delete
    
    
    Note: This performs a soft delete - the testproduct is marked as deleted
    but remains in the database for audit purposes.
    
    """
    try:
        logger.info(f"API: Deleting testproduct {testproduct_id}")
        success = await service.delete_testproduct(testproduct_id)
        
        if not success:
            logger.warning(f"API: TestProduct {testproduct_id} not found for deletion")
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail={"message": f"TestProduct with ID {testproduct_id} not found"}
            )
        
        logger.info(f"API: Deleted testproduct {testproduct_id}")
        
    except HTTPException:
        raise
    except TestProductServiceException as e:
        logger.error(f"API: Service error deleting testproduct {testproduct_id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail={"message": "Failed to delete testproduct", "error": str(e)}
        )


@router.get(
    "/",
    response_model=TestProductList,
    summary="List TestProducts",
    description="Get a paginated list of testproducts with optional filtering.",
    responses={
        200: {"description": "TestProducts retrieved successfully"},
        400: {"description": "Invalid query parameters"},
        500: {"description": "Internal server error"}
    }
)
async def list_testproducts(
    page: int = Query(1, ge=1, description="Page number (1-based)"),
    size: int = Query(10, ge=1, le=100, description="Number of items per page"),
    name_filter: Optional[str] = Query(None, description="Filter by name (partial match)"),
    service: TestProductService = Depends(get_testproduct_service)
) -> TestProductList:
    """
    Get a paginated list of testproducts.
    
    Query parameters:
    - **page**: Page number (default: 1, minimum: 1)
    - **size**: Items per page (default: 10, minimum: 1, maximum: 100)
    - **name_filter**: Filter by name (partial match, optional)
    
    Returns a paginated list with metadata including total count and page information.
    
    Example response:
    ```json
    {
        "items": [
            {
                "id": 1,
                "name": "Sample TestProduct",
                
                "created_at": "2024-01-01T12:00:00Z",
                "updated_at": "2024-01-01T12:00:00Z"
                
            }
        ],
        "total": 50,
        
        "page": 1,
        "size": 10,
        "pages": 5
        
    }
    ```
    """
    try:
        logger.debug(f"API: Listing testproducts: page={page}, size={size}, name_filter={name_filter}")
        result = await service.list_testproducts(
            page=page,
            size=size,
            name_filter=name_filter
        )
        
        logger.debug(f"API: Listed {len(result.items)} testproducts out of {result.total}")
        return result
        
    except TestProductServiceException as e:
        logger.error(f"API: Service error listing testproducts: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail={"message": "Failed to list testproducts", "error": str(e)}
        )


@router.get(
    "/by-name/{name}",
    response_model=TestProductResponse,
    summary="Get TestProduct by name",
    description="Retrieve a testproduct by its name.",
    responses={
        200: {"description": "TestProduct found"},
        404: {"description": "TestProduct not found"},
        500: {"description": "Internal server error"}
    }
)
async def get_testproduct_by_name(
    name: str,
    service: TestProductService = Depends(get_testproduct_service)
) -> TestProductResponse:
    """
    Get a testproduct by its name.
    
    - **name**: Exact name of the testproduct to find
    
    Returns the testproduct data if found.
    """
    try:
        logger.debug(f"API: Getting testproduct by name: {name}")
        result = await service.get_testproduct_by_name(name)
        
        if not result:
            logger.warning(f"API: TestProduct with name '{name}' not found")
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail={"message": f"TestProduct with name '{name}' not found"}
            )
        
        logger.debug(f"API: Found testproduct by name: {name}")
        return result
        
    except HTTPException:
        raise
    except TestProductServiceException as e:
        logger.error(f"API: Service error getting testproduct by name '{name}': {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail={"message": "Failed to retrieve testproduct", "error": str(e)}
        ) 