"""
TestAdvanced service implementation for Advanced level.

This file was auto-generated by Autogen CLI.
Application: test_advanced
Level: Advanced
Generated at: 2025-06-22T16:30:22.531632
"""

from typing import Optional, Any
import logging
import json

from sqlalchemy.ext.asyncio import AsyncSession

from apps.test_advanced.repo.test_advanced_repo import TestAdvancedRepository
from apps.test_advanced.schemas.test_advanced_schemas import (
    TestAdvancedCreate,
    TestAdvancedUpdate,
    TestAdvancedResponse,
    TestAdvancedList,
    TestAdvancedSearchRequest,
    TestAdvancedStatus
)
from apps.test_advanced.exceptions import (
    TestAdvancedServiceException,
    TestAdvancedValidationException,
    TestAdvancedAlreadyExistsError,
    TestAdvancedNotFoundError
)

logger = logging.getLogger("test_advanced.testadvanced")


class TestAdvancedService:
    """
    Advanced service layer for TestAdvanced business logic.
    
    This service provides advanced business logic operations including:
    - Complex validation and business rules
    - Full-text search with relevance scoring
    - Advanced filtering and faceted search
    - Priority and status management
    - Tag-based categorization
    - Comprehensive error handling
    - Advanced soft delete operations
    
    Example:
        >>> async with async_session() as session:
        ...     service = TestAdvancedService(session)
        ...     
        ...     # Advanced search
        ...     search_request = TestAdvancedSearchRequest(
        ...         query="business critical",
        ...         priority_gte=5,
        ...         status=["active", "draft"],
        ...         include_facets=True
        ...     )
        ...     results = await service.search_testadvanceds(search_request)
    """

    def __init__(self, session: AsyncSession):
        """Initialize TestAdvanced service."""
        self.session = session
        self.repository = TestAdvancedRepository(session)

    async def create_testadvanced(self, create_data: TestAdvancedCreate) -> TestAdvancedResponse:
        """Create a new testadvanced with advanced validation."""
        try:
            await self._validate_create_data(create_data)
            
            # Process tags
            processed_data = create_data.model_copy()
            if processed_data.tags:
                processed_data.tags = json.dumps(processed_data.tags)
            
            logger.info(f"Creating advanced testadvanced: {create_data.name}")
            entity = await self.repository.create(processed_data)
            
            return await self._build_response(entity)
            
        except (TestAdvancedValidationException, TestAdvancedAlreadyExistsError):
            raise
        except Exception as e:
            logger.error(f"Failed to create testadvanced: {e}")
            raise TestAdvancedServiceException(
                f"Failed to create testadvanced: {str(e)}",
                operation="create_testadvanced"
            ) from e

    async def get_testadvanced(self, testadvanced_id: int) -> Optional[TestAdvancedResponse]:
        """
        Get testadvanced by ID with computed fields.
        
        Args:
            testadvanced_id: ID of the testadvanced to retrieve
            
        Returns:
            TestAdvanced response with computed fields if found, None otherwise
            
        Raises:
            TestAdvancedServiceException: If retrieval fails
            
        Example:
            >>> testadvanced = await service.get_testadvanced(123)
            >>> if testadvanced:
            ...     print(f"Found: {testadvanced.name} (Priority: {testadvanced.priority})")
        """
        try:
            logger.debug(f"Getting testadvanced with ID: {testadvanced_id}")
            entity = await self.repository.get(testadvanced_id)
            
            if entity:
                return await self._build_response(entity)
            return None
            
        except Exception as e:
            logger.error(f"Failed to get testadvanced {testadvanced_id}: {e}")
            raise TestAdvancedServiceException(
                f"Failed to retrieve testadvanced: {str(e)}",
                operation="get_testadvanced"
            ) from e

    async def update_testadvanced(
        self, 
        testadvanced_id: int, 
        update_data: TestAdvancedUpdate
    ) -> Optional[TestAdvancedResponse]:
        """
        Update testadvanced with advanced business validation.
        
        Args:
            testadvanced_id: ID of the testadvanced to update
            update_data: Data for updating the testadvanced
            
        Returns:
            Updated testadvanced response if found
            
        Raises:
            TestAdvancedValidationException: If validation fails
            TestAdvancedNotFoundError: If testadvanced not found
            TestAdvancedServiceException: If update fails
            
        Example:
            >>> data = TestAdvancedUpdate(
            ...     name="Updated Name",
            ...     priority=9,
            ...     tags=["updated", "high-priority"]
            ... )
            >>> updated = await service.update_testadvanced(123, data)
        """
        try:
            # Check if entity exists
            existing = await self.repository.get(testadvanced_id)
            if not existing:
                raise TestAdvancedNotFoundError(
                    f"TestAdvanced with ID {testadvanced_id} not found",
                    entity_id=testadvanced_id
                )
            
            # Advanced business validation
            await self._validate_update_data(update_data, testadvanced_id)
            
            # Process tags if provided
            processed_data = update_data.model_copy()
            if processed_data.tags is not None:
                processed_data.tags = json.dumps(processed_data.tags) if processed_data.tags else None
            
            # Update entity
            logger.info(f"Updating testadvanced {testadvanced_id}")
            entity = await self.repository.update(testadvanced_id, processed_data)
            
            if entity:
                response = await self._build_response(entity)
                logger.info(f"Updated testadvanced {testadvanced_id}")
                return response
            return None
            
        except (TestAdvancedValidationException, TestAdvancedNotFoundError):
            raise
        except Exception as e:
            logger.error(f"Failed to update testadvanced {testadvanced_id}: {e}")
            raise TestAdvancedServiceException(
                f"Failed to update testadvanced: {str(e)}",
                operation="update_testadvanced"
            ) from e

    async def delete_testadvanced(self, testadvanced_id: int) -> bool:
        """
        Delete testadvanced by ID (soft delete if enabled).
        
        Args:
            testadvanced_id: ID of the testadvanced to delete
            
        Returns:
            True if deleted successfully, False if not found
            
        Raises:
            TestAdvancedServiceException: If deletion fails
            
        Example:
            >>> success = await service.delete_testadvanced(123)
            >>> if success:
            ...     print("TestAdvanced deleted successfully")
        """
        try:
            logger.info(f"Deleting testadvanced {testadvanced_id}")
            success = await self.repository.remove(testadvanced_id)
            
            if success:
                logger.info(f"Deleted testadvanced {testadvanced_id}")
            else:
                logger.warning(f"TestAdvanced {testadvanced_id} not found for deletion")
                
            return success
            
        except Exception as e:
            logger.error(f"Failed to delete testadvanced {testadvanced_id}: {e}")
            raise TestAdvancedServiceException(
                f"Failed to delete testadvanced: {str(e)}",
                operation="delete_testadvanced"
            ) from e

    async def search_testadvanceds(self, search_request: TestAdvancedSearchRequest) -> TestAdvancedList:
        """Advanced search with complex filtering."""
        try:
            logger.debug(f"Advanced search testadvanceds")
            return await self.repository.complex_search(search_request)
        except Exception as e:
            logger.error(f"Failed to search testadvanceds: {e}")
            raise TestAdvancedServiceException(
                f"Failed to search testadvanceds: {str(e)}",
                operation="search_testadvanceds"
            ) from e

    async def get_testadvanced_by_name(self, name: str, status: Optional[TestAdvancedStatus] = None) -> Optional[TestAdvancedResponse]:
        """
        Get testadvanced by name with optional status filter.
        
        Args:
            name: Name to search for
            status: Optional status filter
            
        Returns:
            TestAdvanced response if found
            
        Example:
            >>> testadvanced = await service.get_testadvanced_by_name("Project Alpha", "active")
        """
        try:
            entity = await self.repository.get_by_name_and_status(
                name, status or TestAdvancedStatus.ACTIVE
            )
            if entity:
                return await self._build_response(entity)
            return None
        except Exception as e:
            logger.error(f"Failed to get testadvanced by name '{name}': {e}")
            raise TestAdvancedServiceException(
                f"Failed to get testadvanced by name: {str(e)}",
                operation="get_testadvanced_by_name"
            ) from e

    async def update_priority(self, testadvanced_id: int, priority: int) -> Optional[TestAdvancedResponse]:
        """
        Update testadvanced priority with validation.
        
        Args:
            testadvanced_id: ID of the testadvanced to update
            priority: New priority (0-10)
            
        Returns:
            Updated testadvanced response
            
        Raises:
            TestAdvancedValidationException: If priority is invalid
            
        Example:
            >>> updated = await service.update_priority(123, 9)
        """
        if not (0 <= priority <= 10):
            raise TestAdvancedValidationException(
                "Priority must be between 0 and 10",
                validation_errors=[{"field": "priority", "message": "Invalid priority range"}]
            )
        
        update_data = TestAdvancedUpdate(priority=priority)
        return await self.update_testadvanced(testadvanced_id, update_data)

    async def add_tags(self, testadvanced_id: int, tags: list[str]) -> Optional[TestAdvancedResponse]:
        """
        Add tags to testadvanced.
        
        Args:
            testadvanced_id: ID of the testadvanced
            tags: List of tags to add
            
        Returns:
            Updated testadvanced response
            
        Example:
            >>> updated = await service.add_tags(123, ["urgent", "customer"])
        """
        entity = await self.repository.get(testadvanced_id)
        if not entity:
            raise TestAdvancedNotFoundError(f"TestAdvanced with ID {testadvanced_id} not found")
        
        # Merge with existing tags
        existing_tags = set(entity.tags_list)
        new_tags = list(existing_tags.union(set(tags)))
        
        update_data = TestAdvancedUpdate(tags=new_tags)
        return await self.update_testadvanced(testadvanced_id, update_data)

    async def get_statistics(self) -> dict[str, Any]:
        """
        Get comprehensive statistics about testadvanceds.
        
        Returns:
            Dictionary with various statistics
            
        Example:
            >>> stats = await service.get_statistics()
            >>> print(f"Total active: {stats['total_active']}")
        """
        try:
            # Get basic counts
            total_count = await self.repository.count()
            active_count = await self.repository.count(filters={"status": "active", "is_deleted": False})
            
            # Get priority stats
            priority_stats = await self.repository.get_priority_stats()
            
            # Get status counts
            status_counts = await self.repository.get_status_counts()
            
            return {
                "total_count": total_count,
                "active_count": active_count,
                "priority_stats": priority_stats,
                "status_counts": status_counts,
                "high_priority_count": len(await self.repository.get_by_priority_range(7, 10))
            }
            
        except Exception as e:
            logger.error(f"Failed to get statistics: {e}")
            raise TestAdvancedServiceException(
                f"Failed to get statistics: {str(e)}",
                operation="get_statistics"
            ) from e

    # Private helper methods

    async def _build_response(self, entity) -> TestAdvancedResponse:
        """Build response object with computed fields."""
        response = TestAdvancedResponse.model_validate(entity)
        response.tags_count = len(entity.tags_list) if entity.tags else 0
        response.is_high_priority = entity.priority >= 7
        return response

    async def _validate_create_data(self, create_data: TestAdvancedCreate) -> None:
        """Advanced validation for create data."""
        # Check business rules
        if create_data.priority > 8 and create_data.status != TestAdvancedStatus.ACTIVE:
            raise TestAdvancedValidationException(
                "High priority testadvanceds (>8) must be active",
                validation_errors=[{"field": "status", "message": "High priority items must be active"}]
            )

    async def _validate_update_data(self, update_data: TestAdvancedUpdate, testadvanced_id: int) -> None:
        """Advanced validation for update data."""
        # Check if name already exists (excluding current entity)
        if update_data.name:
            existing = await self.repository.get_by_name_and_status(
                update_data.name, 
                update_data.status or TestAdvancedStatus.ACTIVE
            )
            if existing and existing.id != testadvanced_id:
                raise TestAdvancedValidationException(
                    f"TestAdvanced with name '{update_data.name}' already exists",
                    validation_errors=[{"field": "name", "message": "Name already exists"}]
                )
        
        # Validate business rules
        if update_data.priority and update_data.priority > 8:
            if update_data.status and update_data.status != TestAdvancedStatus.ACTIVE:
                raise TestAdvancedValidationException(
                    "High priority testadvanceds (>8) must be active",
                    validation_errors=[{"field": "status", "message": "High priority items must be active"}]
                ) 