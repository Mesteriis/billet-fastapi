"""
{{ model_name }} Pydantic schemas for Advanced level.

This file was auto-generated by Autogen CLI.
Application: {{ app_name }}
Level: {{ level }}
Generated at: {{ timestamp }}
Template Version: v1.0.0 (Complete)
"""

from typing import Any, Literal
from uuid import UUID
from datetime import datetime

from pydantic import BaseModel, Field, ConfigDict, field_validator
from core.base.models import BaseSchema


class {{ model_name }}Base(BaseModel):
    """
    Base {{ model_name }} schema with common fields for Advanced level.
    
    This schema contains the common fields that are used across
    different {{ model_name }} schemas with advanced features.
    
    Add your custom fields here based on your model definition.
    """
    
    # Add your custom fields here based on your model
    # Example for Advanced level:
    # title: str = Field(..., min_length=1, max_length=200, description="{{ model_name }} title")
    # content: str | None = Field(None, max_length=5000, description="Content text")
    # status: str = Field(default="draft", description="Status (draft, published, archived)")
    # priority: int = Field(default=0, ge=0, le=10, description="Priority level (0-10)")
    # tags: list[str] = Field(default_factory=list, description="List of tags")
    # metadata: dict[str, Any] = Field(default_factory=dict, description="Additional metadata")
    
    pass


class {{ model_name }}Create({{ model_name }}Base):
    """
    Schema for creating a new {{ model_name }} with Advanced features.
    
    This schema defines the required and optional fields
    for creating a new {{ model_name }} instance with extended validation.
    
    Example:
        >>> data = {{ model_name }}Create(
        ...     title="New Advanced {{ model_name }}",
        ...     content="Detailed content",
        ...     tags=["important", "business"],
        ...     priority=8,
        ...     status="draft"
        ... )
        >>> # Use with API endpoint: POST {{ api_config.prefix }}
    """
    pass


class {{ model_name }}Update(BaseModel):
    """
    Schema for updating an existing {{ model_name }} (Advanced level).
    
    All fields are optional to support partial updates.
    Only the provided fields will be updated.
    
    Example:
        >>> data = {{ model_name }}Update(
        ...     title="Updated Title",
        ...     priority=9,
        ...     tags=["updated", "important"]
        ... )
        >>> # Use with API endpoint: PUT {{ api_config.prefix }}/{id}
    """
    
    # Add your custom update fields here (all optional)
    # Example for Advanced level:
    # title: str | None = Field(None, min_length=1, max_length=200, description="Updated title")
    # content: str | None = Field(None, max_length=5000, description="Updated content")
    # status: str | None = Field(None, description="Updated status")
    # priority: int | None = Field(None, ge=0, le=10, description="Updated priority")
    # tags: list[str] | None = Field(None, description="Updated tags list")
    # metadata: dict[str, Any] | None = Field(None, description="Updated metadata")
    
    pass


class {{ model_name }}Response(BaseSchema):
    """
    Schema for {{ model_name }} responses (Advanced level).
    
    This schema is used when returning {{ model_name }} data
    from API endpoints. It includes all fields from the database
    plus computed fields and metadata.
    
    Inherits base fields from BaseSchema:
    - id: UUID
    - created_at: datetime
    - updated_at: datetime
    - deleted_at: datetime | None
    - is_deleted: bool
    
    Example:
        >>> response = {{ model_name }}Response.model_validate(db_{{ model_name.lower() }})
        >>> # Returned from API endpoints: GET {{ api_config.prefix }}
    """
    
    model_config = ConfigDict(from_attributes=True)
    
    # Add your custom response fields here
    # Example for Advanced level:
    # title: str = Field(..., description="{{ model_name }} title")
    # content: str | None = Field(None, description="Content text")
    # status: str = Field(..., description="Current status")
    # priority: int = Field(..., description="Priority level")
    # tags: list[str] = Field(default_factory=list, description="List of tags")
    # metadata: dict[str, Any] = Field(default_factory=dict, description="Additional metadata")
    
    # Advanced computed fields
    search_relevance: float | None = Field(default=None, description="Search relevance score (0.0 - 1.0)")
    facet_data: dict[str, Any] | None = Field(default=None, description="Faceted search metadata")
    
    pass


class {{ model_name }}List(BaseModel):
    """Schema for paginated {{ model_name }} list responses (Advanced level)."""
    
    items: list[{{ model_name }}Response] = Field(
        default_factory=list,
        description="List of {{ model_name.lower() }}s"
    )
    
    total: int = Field(
        default=0,
        ge=0,
        description="Total number of {{ model_name.lower() }}s matching filters"
    )
    
    {% if features.enable_pagination %}
    page: int = Field(default=1, ge=1, description="Current page number")
    size: int = Field(default=20, ge=1, le=100, description="Number of items per page")
    pages: int = Field(default=1, ge=0, description="Total number of pages")
    {% endif %}

    # Advanced metadata
    filters_applied: dict[str, Any] = Field(default_factory=dict, description="Applied filters summary")
    facets: dict[str, dict[str, int]] | None = Field(default=None, description="Faceted search results")
    search_time_ms: float | None = Field(default=None, description="Search execution time in milliseconds")


class {{ model_name }}SearchRequest(BaseModel):
    """Schema for advanced search requests."""
    
    query: str | None = Field(default=None, max_length=500, description="Full-text search query")
    search_fields: list[str] | None = Field(default=None, description="Fields to search in")
    sort_by: str = Field(default="created_at", description="Sort field")
    sort_order: Literal["asc", "desc"] = Field(default="desc", description="Sort order")
    page: int = Field(default=1, ge=1, description="Page number")
    size: int = Field(default=20, ge=1, le=100, description="Items per page")
    include_facets: bool = Field(default=False, description="Include faceted search results")
    include_aggregations: bool = Field(default=False, description="Include aggregation results")

    @field_validator('search_fields')
    @classmethod
    def validate_search_fields(cls, v: list[str] | None) -> list[str] | None:
        """Validate search fields."""
        if v is not None:
            v = list(set(field.strip() for field in v if field.strip()))
            if len(v) > 5:
                raise ValueError("Maximum 5 search fields allowed")
        return v


class {{ model_name }}Filter(BaseModel):
    """Schema for filtering {{ model_name }} queries (Advanced level)."""
    
    # Base filters
    id: UUID | None = None
    created_at__gte: datetime | None = None
    created_at__lte: datetime | None = None
    updated_at__gte: datetime | None = None
    updated_at__lte: datetime | None = None
    deleted_at__isnull: bool | None = None
    
    # Advanced search filters
    search_query: str | None = None
    search_fields: list[str] | None = None
    
    # Add custom filters based on your model fields here
    # Example for Advanced level:
    # title__icontains: str | None = None
    # content__search: str | None = None
    # status__in: list[str] | None = None
    # priority__gte: int | None = None
    # priority__lte: int | None = None
    # tags__contains: str | None = None
    # metadata__has_key: str | None = None
    
    model_config = ConfigDict(extra='allow')

    @field_validator('search_fields')
    @classmethod
    def validate_search_fields(cls, v: list[str] | None) -> list[str] | None:
        """Validate search fields."""
        if v is not None:
            v = list(set(field.strip() for field in v if field.strip()))
            if len(v) > 5:
                raise ValueError("Maximum 5 search fields allowed")
        return v


class {{ model_name }}AggregationRequest(BaseModel):
    """Schema for aggregation requests."""
    
    field: str = Field(..., description="Field to aggregate")
    operations: list[Literal["count", "sum", "avg", "min", "max"]] = Field(
        default=["count"], 
        description="Aggregation operations"
    )
    group_by: str | None = Field(default=None, description="Field to group by")
    filters: dict[str, Any] = Field(default_factory=dict, description="Filters to apply before aggregation")


class {{ model_name }}AggregationResponse(BaseModel):
    """Schema for aggregation responses."""
    
    field_name: str = Field(..., description="Name of aggregated field")
    count: int | None = None
    sum: float | None = None
    avg: float | None = None
    min: Any | None = None
    max: Any | None = None
    group_by: dict[str, Any] | None = Field(default=None, description="Grouping information if used")


# Convenient type aliases for better code readability
{{ model_name }}CreateData = {{ model_name }}Create
{{ model_name }}UpdateData = {{ model_name }}Update
{{ model_name }}ResponseData = {{ model_name }}Response
{{ model_name }}FilterData = {{ model_name }}Filter
{{ model_name }}SearchData = {{ model_name }}SearchRequest 