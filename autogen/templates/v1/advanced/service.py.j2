"""
{{ model_name }} service implementation for Advanced level.

This file was auto-generated by Autogen CLI.
Application: {{ app_name }}
Level: {{ level }}
Generated at: {{ timestamp }}
Template Version: v1.0.0 (Complete)
"""

import logging
from typing import Dict, List, Any

from sqlalchemy.ext.asyncio import AsyncSession

from apps.{{ app_name }}.repo.{{ app_name }}_repo import {{ model_name }}Repository
from apps.{{ app_name }}.schemas.{{ app_name }}_schemas import (
    {{ model_name }}Create,
    {{ model_name }}Update,
    {{ model_name }}Response,
    {{ model_name }}List,
    {{ model_name }}SearchRequest,
    {{ model_name }}AggregationRequest,
    {{ model_name }}AggregationResponse
)
from apps.{{ app_name }}.exceptions import (
    {{ model_name }}ServiceException,
    {{ model_name }}ValidationException
)

logger = logging.getLogger("{{ app_name }}.{{ model_name.lower() }}_advanced")


class {{ model_name }}Service:
    """
    Advanced service layer for {{ model_name }} business logic.
    
    This service provides advanced business logic operations including:
    - Full-text search capabilities
    - Complex filtering and aggregations
    - Performance optimizations
    - Advanced validation rules
    - Statistics and analytics
    
    Example:
        >>> service = {{ model_name }}Service(session)
        >>> 
        >>> # Advanced search
        >>> search_req = {{ model_name }}SearchRequest(
        ...     query="important project",
        ...     include_facets=True
        ... )
        >>> results = await service.search_{{ model_name.lower() }}s(search_req)
        >>> 
        >>> # Aggregations
        >>> agg_req = {{ model_name }}AggregationRequest(
        ...     field="priority",
        ...     operations=["count", "avg"]
        ... )
        >>> stats = await service.aggregate_{{ model_name.lower() }}s(agg_req)
    """

    def __init__(self, session: AsyncSession):
        """Initialize Advanced {{ model_name }} service."""
        self.session = session
        self.repository = {{ model_name }}Repository(session)

    async def create_{{ model_name.lower() }}(self, create_data: {{ model_name }}Create) -> {{ model_name }}Response:
        """Create with advanced validation."""
        try:
            await self._validate_create_data(create_data)
            
            logger.info(f"Creating advanced {{ model_name.lower() }}: {create_data.name}")
            entity = await self.repository.create(create_data)
            
            response = {{ model_name }}Response.model_validate(entity)
            logger.info(f"Created advanced {{ model_name.lower() }} with ID: {response.id}")
            
            return response
            
        except {{ model_name }}ValidationException:
            raise
        except Exception as e:
            logger.error(f"Failed to create advanced {{ model_name.lower() }}: {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to create {{ model_name.lower() }}: {str(e)}",
                operation="create_advanced_{{ model_name.lower() }}"
            ) from e

    async def get_{{ model_name.lower() }}(self, {{ model_name.lower() }}_id: int) -> {{ model_name }}Response | None:
        """Get with performance optimization."""
        try:
            logger.debug(f"Getting {{ model_name.lower() }} with ID: {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}")
            entity = await self.repository.get({{ model_name.lower() }}_id)
            
            if entity:
                return {{ model_name }}Response.model_validate(entity)
            return None
            
        except Exception as e:
            logger.error(f"Failed to get {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}: {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to retrieve {{ model_name.lower() }}: {str(e)}",
                operation="get_{{ model_name.lower() }}"
            ) from e

    async def update_{{ model_name.lower() }}(
        self, 
        {{ model_name.lower() }}_id: int, 
        update_data: {{ model_name }}Update
    ) -> {{ model_name }}Response | None:
        """Update with advanced validation."""
        try:
            await self._validate_update_data(update_data, {{ model_name.lower() }}_id)
            
            logger.info(f"Updating {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}")
            entity = await self.repository.update({{ model_name.lower() }}_id, update_data)
            
            if entity:
                response = {{ model_name }}Response.model_validate(entity)
                logger.info(f"Updated {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}")
                return response
            return None
            
        except {{ model_name }}ValidationException:
            raise
        except Exception as e:
            logger.error(f"Failed to update {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}: {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to update {{ model_name.lower() }}: {str(e)}",
                operation="update_{{ model_name.lower() }}"
            ) from e

    async def delete_{{ model_name.lower() }}(self, {{ model_name.lower() }}_id: int) -> bool:
        """Delete with cleanup."""
        try:
            logger.info(f"Deleting {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}")
            success = await self.repository.remove({{ model_name.lower() }}_id)
            
            if success:
                logger.info(f"Deleted {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}")
            
            return success
            
        except Exception as e:
            logger.error(f"Failed to delete {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}: {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to delete {{ model_name.lower() }}: {str(e)}",
                operation="delete_{{ model_name.lower() }}"
            ) from e

    async def search_{{ model_name.lower() }}s(self, search_request: {{ model_name }}SearchRequest) -> {{ model_name }}List:
        """Advanced search with facets and aggregations."""
        try:
            logger.debug(f"Advanced search for {{ model_name.lower() }}s: {search_request}")
            result = await self.repository.search(search_request)
            
            logger.debug(f"Found {len(result.items)} {{ model_name.lower() }}s")
            return result
            
        except Exception as e:
            logger.error(f"Failed to search {{ model_name.lower() }}s: {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to search {{ model_name.lower() }}s: {str(e)}",
                operation="search_{{ model_name.lower() }}s"
            ) from e

    async def aggregate_{{ model_name.lower() }}s(self, agg_request: {{ model_name }}AggregationRequest) -> {{ model_name }}AggregationResponse:
        """Perform aggregations on {{ model_name.lower() }} data."""
        try:
            logger.debug(f"Aggregating {{ model_name.lower() }}s: {agg_request}")
            result = await self.repository.aggregate(agg_request)
            
            logger.debug(f"Aggregation completed for field: {agg_request.field}")
            return result
            
        except Exception as e:
            logger.error(f"Failed to aggregate {{ model_name.lower() }}s: {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to aggregate {{ model_name.lower() }}s: {str(e)}",
                operation="aggregate_{{ model_name.lower() }}s"
            ) from e

    async def get_{{ model_name.lower() }}_by_name(self, name: str, status: str | None = None) -> {{ model_name }}Response | None:
        """Get by name with optional status filter."""
        try:
            entity = await self.repository.get_by_name(name, status)
            if entity:
                return {{ model_name }}Response.model_validate(entity)
            return None
        except Exception as e:
            logger.error(f"Failed to get {{ model_name.lower() }} by name '{name}': {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to get {{ model_name.lower() }} by name: {str(e)}",
                operation="get_{{ model_name.lower() }}_by_name"
            ) from e

    async def update_priority(self, {{ model_name.lower() }}_id: int, priority: int) -> {{ model_name }}Response | None:
        """Update priority with validation."""
        try:
            if not 0 <= priority <= 10:
                raise {{ model_name }}ValidationException(
                    "Priority must be between 0 and 10",
                    validation_errors=[{"field": "priority", "message": "Invalid priority value"}]
                )
            
            update_data = {{ model_name }}Update(priority=priority)
            return await self.update_{{ model_name.lower() }}({{ model_name.lower() }}_id, update_data)
            
        except Exception as e:
            logger.error(f"Failed to update priority for {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}: {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to update priority: {str(e)}",
                operation="update_priority"
            ) from e

    async def add_tags(self, {{ model_name.lower() }}_id: int, tags: List[str]) -> {{ model_name }}Response | None:
        """Add tags to entity."""
        try:
            # Get current entity
            entity = await self.repository.get({{ model_name.lower() }}_id)
            if not entity:
                return None
            
            # Merge tags (assuming tags are stored as JSON)
            current_tags = entity.tags_list if hasattr(entity, 'tags_list') else []
            new_tags = list(set(current_tags + tags))
            
            update_data = {{ model_name }}Update(tags=new_tags)
            return await self.update_{{ model_name.lower() }}({{ model_name.lower() }}_id, update_data)
            
        except Exception as e:
            logger.error(f"Failed to add tags to {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}: {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to add tags: {str(e)}",
                operation="add_tags"
            ) from e

    async def get_statistics(self) -> Dict[str, Any]:
        """Get comprehensive statistics."""
        try:
            stats = await self.repository.get_statistics()
            logger.debug(f"Retrieved statistics for {{ model_name.lower() }}s")
            return stats
        except Exception as e:
            logger.error(f"Failed to get statistics: {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to get statistics: {str(e)}",
                operation="get_statistics"
            ) from e

    # Private validation methods
    async def _validate_create_data(self, create_data: {{ model_name }}Create) -> None:
        """Advanced validation for create data."""
        # Basic validation from parent
        if await self.repository.exists_by_name(create_data.name):
            raise {{ model_name }}ValidationException(
                f"{{ model_name }} with name '{create_data.name}' already exists",
                validation_errors=[{"field": "name", "message": "Name already exists"}]
            )

    async def _validate_update_data(self, update_data: {{ model_name }}Update, {{ model_name.lower() }}_id: int) -> None:
        """Advanced validation for update data."""
        if update_data.name:
            existing = await self.repository.get_by_name(update_data.name)
            if existing and existing.id != {{ model_name.lower() }}_id:
                raise {{ model_name }}ValidationException(
                    f"{{ model_name }} with name '{update_data.name}' already exists",
                    validation_errors=[{"field": "name", "message": "Name already exists"}]
                ) 