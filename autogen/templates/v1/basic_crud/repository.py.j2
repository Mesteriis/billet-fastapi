"""
{{ model_name }} repository implementation.

This file was auto-generated by Autogen CLI.
Application: {{ app_name }}
Level: {{ level }}
Generated at: {{ timestamp }}
Template Version: v1.0.0 (Complete)
"""

from sqlalchemy.ext.asyncio import AsyncSession

from core.base.repo import SimpleRepository
from apps.{{ app_name }}.models.{{ app_name }}_models import {{ model_name }}
from apps.{{ app_name }}.schemas.{{ app_name }}_schemas import (
    {{ model_name }}Create,
    {{ model_name }}Update,
    {{ model_name }}Response,
    {{ model_name }}List
)


class {{ model_name }}Repository(SimpleRepository[{{ model_name }}, {{ model_name }}Create, {{ model_name }}Update]):
    """
    Repository for {{ model_name }} entities with basic CRUD operations.
    
    This repository provides basic CRUD functionality using SimpleRepository
    which includes:
    - Basic CRUD operations (create, get, update, remove, restore, list, count)
    - Simple filters (eq, ne, lt, lte, gt, gte, isnull, isnotnull)
    {% if features.enable_soft_delete %}- Soft delete support{% endif %}
    {% if features.enable_pagination %}- Pagination support{% endif %}
    
    Example:
        >>> async with async_session() as session:
        ...     repo = {{ model_name }}Repository(session)
        ...     
        ...     # Create new {{ model_name.lower() }}
        ...     create_data = {{ model_name }}Create(name="Test {{ model_name }}")
        ...     {{ model_name.lower() }} = await repo.create(create_data)
        ...     
        ...     # Get by ID
        ...     found = await repo.get({{ model_name.lower() }}.id)
        ...     
        ...     # List with filters
        ...     results = await repo.list(filters={"name__ilike": "%test%"})
        ...     
        ...     # Update
        ...     update_data = {{ model_name }}Update(name="Updated Name")
        ...     updated = await repo.update({{ model_name.lower() }}.id, update_data)
        ...     
        ...     # Delete
        ...     await repo.remove({{ model_name.lower() }}.id)
    """

    def __init__(self, session: AsyncSession):
        """
        Initialize {{ model_name }} repository.
        
        Args:
            session: Database session for operations
        """
        super().__init__(model={{ model_name }}, session=session)

    async def get_by_name(self, name: str) -> {{ model_name }} | None:
        """
        Get {{ model_name.lower() }} by name.
        
        Args:
            name: The name to search for
            
        Returns:
            {{ model_name }} instance if found, None otherwise
            
        Example:
            >>> {{ model_name.lower() }} = await repo.get_by_name("Sample {{ model_name }}")
        """
        return await self.get_by(name=name)

    async def list_active(
        self,
        page: int = 1,
        size: int = 10,
        filters: dict | None = None
    ) -> {{ model_name }}List:
        """
        Get list of active (non-deleted) {{ model_name.lower() }}s with pagination.
        
        Args:
            page: Page number (1-based)
            size: Number of items per page
            filters: Additional filters to apply
            
        Returns:
            {{ model_name }}List with paginated results
            
        Example:
            >>> result = await repo.list_active(page=1, size=20)
            >>> print(f"Found {result.total} {{ model_name.lower() }}s")
            >>> for {{ model_name.lower() }} in result.items:
            ...     print({{ model_name.lower() }}.name)
        """
        # Prepare filters
        active_filters = filters or {}
        {% if features.enable_soft_delete %}
        active_filters["is_deleted"] = False
        {% endif %}
        
        # Get paginated results
        items, total = await self.list(
            page=page,
            size=size,
            filters=active_filters
        )
        
        # Calculate pagination metadata
        pages = (total + size - 1) // size  # Ceiling division
        
        return {{ model_name }}List(
            items=[{{ model_name }}Response.model_validate(item) for item in items],
            total=total,
            {% if features.enable_pagination %}
            page=page,
            size=size,
            pages=pages
            {% endif %}
        )

    async def count_active(self) -> int:
        """
        Count active (non-deleted) {{ model_name.lower() }}s.
        
        Returns:
            Number of active {{ model_name.lower() }}s
            
        Example:
            >>> count = await repo.count_active()
            >>> print(f"Active {{ model_name.lower() }}s: {count}")
        """
        {% if features.enable_soft_delete %}
        return await self.count(filters={"is_deleted": False})
        {% else %}
        return await self.count()
        {% endif %}

    async def exists_by_name(self, name: str) -> bool:
        """
        Check if {{ model_name.lower() }} with given name exists.
        
        Args:
            name: The name to check
            
        Returns:
            True if {{ model_name.lower() }} exists, False otherwise
            
        Example:
            >>> exists = await repo.exists_by_name("Sample {{ model_name }}")
            >>> if exists:
            ...     print("{{ model_name }} already exists")
        """
        return await self.exists(filters={"name": name{% if features.enable_soft_delete %}, "is_deleted": False{% endif %}})

    {% if features.enable_soft_delete %}
    async def soft_delete(self, entity_id: int) -> {{ model_name }} | None:
        """
        Soft delete {{ model_name.lower() }} by ID.
        
        Args:
            entity_id: ID of the {{ model_name.lower() }} to soft delete
            
        Returns:
            Soft deleted {{ model_name }} instance if found
            
        Example:
            >>> deleted = await repo.soft_delete(123)
            >>> if deleted:
            ...     print(f"Soft deleted: {deleted.name}")
        """
        update_data = {{ model_name }}Update(is_deleted=True)
        return await self.update(entity_id, update_data)

    async def restore_from_soft_delete(self, entity_id: int) -> {{ model_name }} | None:
        """
        Restore {{ model_name.lower() }} from soft delete.
        
        Args:
            entity_id: ID of the {{ model_name.lower() }} to restore
            
        Returns:
            Restored {{ model_name }} instance if found
            
        Example:
            >>> restored = await repo.restore_from_soft_delete(123)
            >>> if restored:
            ...     print(f"Restored: {restored.name}")
        """
        update_data = {{ model_name }}Update(is_deleted=False)
        return await self.update(entity_id, update_data)
    {% endif %} 