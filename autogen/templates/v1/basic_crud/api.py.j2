"""
{{ model_name }} API routes.

This file was auto-generated by Autogen CLI.
Application: {{ app_name }}
Level: {{ level }}
Generated at: {{ timestamp }}
Template Version: v1.0.0 (Complete)
"""

import logging

from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession

from core.database import get_async_session
from apps.{{ app_name }}.services.{{ app_name }}_service import {{ model_name }}Service
from apps.{{ app_name }}.schemas.{{ app_name }}_schemas import (
    {{ model_name }}Create,
    {{ model_name }}Update,
    {{ model_name }}Response,
    {{ model_name }}List
)
from apps.{{ app_name }}.exceptions import (
    {{ model_name }}ValidationException,
    {{ model_name }}ServiceException
)

logger = logging.getLogger("api.{{ app_name }}")

# Create router for {{ model_name }} endpoints
router = APIRouter(prefix="{{ api_config.prefix }}", tags={{ api_config.tags }})


async def get_{{ model_name.lower() }}_service(
    session: AsyncSession = Depends(get_async_session)
) -> {{ model_name }}Service:
    """
    Dependency to get {{ model_name }} service instance.
    
    Args:
        session: Database session from dependency injection
        
    Returns:
        {{ model_name }}Service instance
    """
    return {{ model_name }}Service(session)


@router.post(
    "/",
    response_model={{ model_name }}Response,
    status_code=status.HTTP_201_CREATED,
    summary="Create {{ model_name }}",
    description="Create a new {{ model_name.lower() }} with the provided data.",
    responses={
        201: {"description": "{{ model_name }} created successfully"},
        400: {"description": "Validation error"},
        409: {"description": "{{ model_name }} already exists"},
        500: {"description": "Internal server error"}
    }
)
async def create_{{ model_name.lower() }}(
    create_data: {{ model_name }}Create,
    service: {{ model_name }}Service = Depends(get_{{ model_name.lower() }}_service)
) -> {{ model_name }}Response:
    """
    Create a new {{ model_name.lower() }}.
    
    - **name**: {{ model_name }} name (required, 1-255 characters)
    
    Returns the created {{ model_name.lower() }} with its assigned ID and metadata.
    
    Example request:
    ```json
    {
        "name": "Sample {{ model_name }}"
    }
    ```
    """
    try:
        logger.info(f"API: Creating {{ model_name.lower() }}: {create_data.name}")
        result = await service.create_{{ model_name.lower() }}(create_data)
        logger.info(f"API: Created {{ model_name.lower() }} with ID: {result.id}")
        return result
        
    except {{ model_name }}ValidationException as e:
        logger.warning(f"API: Validation error creating {{ model_name.lower() }}: {e}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail={"message": str(e), "errors": e.details.get("validation_errors", [])}
        )
    except {{ model_name }}ServiceException as e:
        logger.error(f"API: Service error creating {{ model_name.lower() }}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail={"message": "Failed to create {{ model_name.lower() }}", "error": str(e)}
        )


@router.get(
    "/{{ '{' }}{{ model_name.lower() }}_id{{ '}' }}",
    response_model={{ model_name }}Response,
    summary="Get {{ model_name }} by ID",
    description="Retrieve a specific {{ model_name.lower() }} by its ID.",
    responses={
        200: {"description": "{{ model_name }} found"},
        404: {"description": "{{ model_name }} not found"},
        500: {"description": "Internal server error"}
    }
)
async def get_{{ model_name.lower() }}(
    {{ model_name.lower() }}_id: int,
    service: {{ model_name }}Service = Depends(get_{{ model_name.lower() }}_service)
) -> {{ model_name }}Response:
    """
    Get a {{ model_name.lower() }} by its ID.
    
    - **{{ model_name.lower() }}_id**: Unique identifier of the {{ model_name.lower() }}
    
    Returns the {{ model_name.lower() }} data if found.
    """
    try:
        logger.debug(f"API: Getting {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}")
        result = await service.get_{{ model_name.lower() }}({{ model_name.lower() }}_id)
        
        if not result:
            logger.warning(f"API: {{ model_name }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }} not found")
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail={"message": f"{{ model_name }} with ID {{ '{' }}{{ model_name.lower() }}_id{{ '}' }} not found"}
            )
        
        logger.debug(f"API: Found {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}")
        return result
        
    except HTTPException:
        raise
    except {{ model_name }}ServiceException as e:
        logger.error(f"API: Service error getting {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail={"message": "Failed to retrieve {{ model_name.lower() }}", "error": str(e)}
        )


@router.put(
    "/{{ '{' }}{{ model_name.lower() }}_id{{ '}' }}",
    response_model={{ model_name }}Response,
    summary="Update {{ model_name }}",
    description="Update an existing {{ model_name.lower() }} with new data.",
    responses={
        200: {"description": "{{ model_name }} updated successfully"},
        400: {"description": "Validation error"},
        404: {"description": "{{ model_name }} not found"},
        409: {"description": "{{ model_name }} name already exists"},
        500: {"description": "Internal server error"}
    }
)
async def update_{{ model_name.lower() }}(
    {{ model_name.lower() }}_id: int,
    update_data: {{ model_name }}Update,
    service: {{ model_name }}Service = Depends(get_{{ model_name.lower() }}_service)
) -> {{ model_name }}Response:
    """
    Update an existing {{ model_name.lower() }}.
    
    - **{{ model_name.lower() }}_id**: Unique identifier of the {{ model_name.lower() }}
    - **name**: New {{ model_name.lower() }} name (optional)
    
    Returns the updated {{ model_name.lower() }} data.
    
    Example request:
    ```json
    {
        "name": "Updated {{ model_name }} Name"
    }
    ```
    """
    try:
        logger.info(f"API: Updating {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}")
        result = await service.update_{{ model_name.lower() }}({{ model_name.lower() }}_id, update_data)
        
        if not result:
            logger.warning(f"API: {{ model_name }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }} not found for update")
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail={"message": f"{{ model_name }} with ID {{ '{' }}{{ model_name.lower() }}_id{{ '}' }} not found"}
            )
        
        logger.info(f"API: Updated {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}")
        return result
        
    except HTTPException:
        raise
    except {{ model_name }}ValidationException as e:
        logger.warning(f"API: Validation error updating {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}: {e}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail={"message": str(e), "errors": e.details.get("validation_errors", [])}
        )
    except {{ model_name }}ServiceException as e:
        logger.error(f"API: Service error updating {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail={"message": "Failed to update {{ model_name.lower() }}", "error": str(e)}
        )


@router.delete(
    "/{{ '{' }}{{ model_name.lower() }}_id{{ '}' }}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete {{ model_name }}",
    description="Delete a {{ model_name.lower() }} by its ID.",
    responses={
        204: {"description": "{{ model_name }} deleted successfully"},
        404: {"description": "{{ model_name }} not found"},
        500: {"description": "Internal server error"}
    }
)
async def delete_{{ model_name.lower() }}(
    {{ model_name.lower() }}_id: int,
    service: {{ model_name }}Service = Depends(get_{{ model_name.lower() }}_service)
) -> None:
    """
    Delete a {{ model_name.lower() }} by its ID.
    
    - **{{ model_name.lower() }}_id**: Unique identifier of the {{ model_name.lower() }} to delete
    
    {% if features.enable_soft_delete %}
    Note: This performs a soft delete - the {{ model_name.lower() }} is marked as deleted
    but remains in the database for audit purposes.
    {% endif %}
    """
    try:
        logger.info(f"API: Deleting {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}")
        success = await service.delete_{{ model_name.lower() }}({{ model_name.lower() }}_id)
        
        if not success:
            logger.warning(f"API: {{ model_name }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }} not found for deletion")
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail={"message": f"{{ model_name }} with ID {{ '{' }}{{ model_name.lower() }}_id{{ '}' }} not found"}
            )
        
        logger.info(f"API: Deleted {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}")
        
    except HTTPException:
        raise
    except {{ model_name }}ServiceException as e:
        logger.error(f"API: Service error deleting {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail={"message": "Failed to delete {{ model_name.lower() }}", "error": str(e)}
        )


@router.get(
    "/",
    response_model={{ model_name }}List,
    summary="List {{ model_name }}s",
    description="Get a paginated list of {{ model_name.lower() }}s with optional filtering.",
    responses={
        200: {"description": "{{ model_name }}s retrieved successfully"},
        400: {"description": "Invalid query parameters"},
        500: {"description": "Internal server error"}
    }
)
async def list_{{ model_name.lower() }}s(
    page: int = Query(1, ge=1, description="Page number (1-based)"),
    size: int = Query(10, ge=1, le=100, description="Number of items per page"),
    name_filter: str | None = Query(None, description="Filter by name (partial match)"),
    service: {{ model_name }}Service = Depends(get_{{ model_name.lower() }}_service)
) -> {{ model_name }}List:
    """
    Get a paginated list of {{ model_name.lower() }}s.
    
    Query parameters:
    - **page**: Page number (default: 1, minimum: 1)
    - **size**: Items per page (default: 10, minimum: 1, maximum: 100)
    - **name_filter**: Filter by name (partial match, optional)
    
    Returns a paginated list with metadata including total count and page information.
    
    Example response:
    ```json
    {
        "items": [
            {
                "id": 1,
                "name": "Sample {{ model_name }}",
                {% if features.enable_timestamps %}
                "created_at": "2024-01-01T12:00:00Z",
                "updated_at": "2024-01-01T12:00:00Z"
                {% endif %}
            }
        ],
        "total": 50,
        {% if features.enable_pagination %}
        "page": 1,
        "size": 10,
        "pages": 5
        {% endif %}
    }
    ```
    """
    try:
        logger.debug(f"API: Listing {{ model_name.lower() }}s: page={page}, size={size}, name_filter={name_filter}")
        result = await service.list_{{ model_name.lower() }}s(
            page=page,
            size=size,
            name_filter=name_filter
        )
        
        logger.debug(f"API: Listed {len(result.items)} {{ model_name.lower() }}s out of {result.total}")
        return result
        
    except {{ model_name }}ServiceException as e:
        logger.error(f"API: Service error listing {{ model_name.lower() }}s: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail={"message": "Failed to list {{ model_name.lower() }}s", "error": str(e)}
        )


@router.get(
    "/by-name/{name}",
    response_model={{ model_name }}Response,
    summary="Get {{ model_name }} by name",
    description="Retrieve a {{ model_name.lower() }} by its name.",
    responses={
        200: {"description": "{{ model_name }} found"},
        404: {"description": "{{ model_name }} not found"},
        500: {"description": "Internal server error"}
    }
)
async def get_{{ model_name.lower() }}_by_name(
    name: str,
    service: {{ model_name }}Service = Depends(get_{{ model_name.lower() }}_service)
) -> {{ model_name }}Response:
    """
    Get a {{ model_name.lower() }} by its name.
    
    - **name**: Exact name of the {{ model_name.lower() }} to find
    
    Returns the {{ model_name.lower() }} data if found.
    """
    try:
        logger.debug(f"API: Getting {{ model_name.lower() }} by name: {name}")
        result = await service.get_{{ model_name.lower() }}_by_name(name)
        
        if not result:
            logger.warning(f"API: {{ model_name }} with name '{name}' not found")
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail={"message": f"{{ model_name }} with name '{name}' not found"}
            )
        
        logger.debug(f"API: Found {{ model_name.lower() }} by name: {name}")
        return result
        
    except HTTPException:
        raise
    except {{ model_name }}ServiceException as e:
        logger.error(f"API: Service error getting {{ model_name.lower() }} by name '{name}': {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail={"message": "Failed to retrieve {{ model_name.lower() }}", "error": str(e)}
        ) 