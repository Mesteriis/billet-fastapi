"""
{{ model_name }} service implementation.

This file was auto-generated by Autogen CLI.
Application: {{ app_name }}
Level: {{ level }}
Generated at: {{ timestamp }}
Template Version: v1.0.0 (Complete)
"""

import logging

from sqlalchemy.ext.asyncio import AsyncSession

from apps.{{ app_name }}.repo.{{ app_name }}_repo import {{ model_name }}Repository
from apps.{{ app_name }}.schemas.{{ app_name }}_schemas import (
    {{ model_name }}Create,
    {{ model_name }}Update,
    {{ model_name }}Response,
    {{ model_name }}List
)
from apps.{{ app_name }}.exceptions import (
    {{ model_name }}ServiceException,
    {{ model_name }}ValidationException
)

logger = logging.getLogger("{{ app_name }}.{{ model_name.lower() }}")


class {{ model_name }}Service:
    """
    Service layer for {{ model_name }} business logic.
    
    This service provides business logic operations for {{ model_name }} entities,
    including validation, error handling, and coordination between different
    components.
    
    Features:
    - Business logic validation
    - Exception handling with detailed context
    - Logging of operations
    {% if features.enable_soft_delete %}- Soft delete operations{% endif %}
    - Comprehensive error messages
    
    Example:
        >>> async with async_session() as session:
        ...     service = {{ model_name }}Service(session)
        ...     
        ...     # Create with validation
        ...     create_data = {{ model_name }}Create(name="Business {{ model_name }}")
        ...     {{ model_name.lower() }} = await service.create_{{ model_name.lower() }}(create_data)
        ...     
        ...     # Get with error handling
        ...     found = await service.get_{{ model_name.lower() }}({{ model_name.lower() }}.id)
        ...     
        ...     # List with business filters
        ...     result = await service.list_{{ model_name.lower() }}s(page=1, size=10)
    """

    def __init__(self, session: AsyncSession):
        """
        Initialize {{ model_name }} service.
        
        Args:
            session: Database session for operations
        """
        self.session = session
        self.repository = {{ model_name }}Repository(session)

    async def create_{{ model_name.lower() }}(self, create_data: {{ model_name }}Create) -> {{ model_name }}Response:
        """
        Create a new {{ model_name.lower() }} with business validation.
        
        Args:
            create_data: Data for creating the {{ model_name.lower() }}
            
        Returns:
            Created {{ model_name.lower() }} response
            
        Raises:
            {{ model_name }}ValidationException: If validation fails
            {{ model_name }}ServiceException: If creation fails
            
        Example:
            >>> data = {{ model_name }}Create(name="New {{ model_name }}")
            >>> {{ model_name.lower() }} = await service.create_{{ model_name.lower() }}(data)
        """
        try:
            # Business validation
            await self._validate_create_data(create_data)
            
            # Create entity
            logger.info(f"Creating {{ model_name.lower() }}: {create_data.name}")
            entity = await self.repository.create(create_data)
            
            # Convert to response
            response = {{ model_name }}Response.model_validate(entity)
            logger.info(f"Created {{ model_name.lower() }} with ID: {response.id}")
            
            return response
            
        except {{ model_name }}ValidationException:
            # Re-raise validation exceptions
            raise
        except Exception as e:
            logger.error(f"Failed to create {{ model_name.lower() }}: {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to create {{ model_name.lower() }}: {str(e)}",
                operation="create_{{ model_name.lower() }}"
            ) from e

    async def get_{{ model_name.lower() }}(self, {{ model_name.lower() }}_id: int) -> {{ model_name }}Response | None:
        """
        Get {{ model_name.lower() }} by ID with error handling.
        
        Args:
            {{ model_name.lower() }}_id: ID of the {{ model_name.lower() }} to retrieve
            
        Returns:
            {{ model_name }} response if found, None otherwise
            
        Raises:
            {{ model_name }}ServiceException: If retrieval fails
            
        Example:
            >>> {{ model_name.lower() }} = await service.get_{{ model_name.lower() }}(123)
            >>> if {{ model_name.lower() }}:
            ...     print(f"Found: {{ '{' }}{{ model_name.lower() }}.name{{ '}' }}")
        """
        try:
            logger.debug(f"Getting {{ model_name.lower() }} with ID: {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}")
            entity = await self.repository.get({{ model_name.lower() }}_id)
            
            if entity:
                return {{ model_name }}Response.model_validate(entity)
            return None
            
        except Exception as e:
            logger.error(f"Failed to get {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}: {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to retrieve {{ model_name.lower() }}: {str(e)}",
                operation="get_{{ model_name.lower() }}"
            ) from e

    async def update_{{ model_name.lower() }}(
        self, 
        {{ model_name.lower() }}_id: int, 
        update_data: {{ model_name }}Update
    ) -> {{ model_name }}Response | None:
        """
        Update {{ model_name.lower() }} with business validation.
        
        Args:
            {{ model_name.lower() }}_id: ID of the {{ model_name.lower() }} to update
            update_data: Data for updating the {{ model_name.lower() }}
            
        Returns:
            Updated {{ model_name.lower() }} response if found
            
        Raises:
            {{ model_name }}ValidationException: If validation fails
            {{ model_name }}ServiceException: If update fails
            
        Example:
            >>> data = {{ model_name }}Update(name="Updated Name")
            >>> updated = await service.update_{{ model_name.lower() }}(123, data)
        """
        try:
            # Business validation
            await self._validate_update_data(update_data, {{ model_name.lower() }}_id)
            
            # Update entity
            logger.info(f"Updating {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}")
            entity = await self.repository.update({{ model_name.lower() }}_id, update_data)
            
            if entity:
                response = {{ model_name }}Response.model_validate(entity)
                logger.info(f"Updated {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}")
                return response
            return None
            
        except {{ model_name }}ValidationException:
            raise
        except Exception as e:
            logger.error(f"Failed to update {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}: {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to update {{ model_name.lower() }}: {str(e)}",
                operation="update_{{ model_name.lower() }}"
            ) from e

    async def delete_{{ model_name.lower() }}(self, {{ model_name.lower() }}_id: int) -> bool:
        """
        Delete {{ model_name.lower() }} by ID.
        
        Args:
            {{ model_name.lower() }}_id: ID of the {{ model_name.lower() }} to delete
            
        Returns:
            True if deleted successfully, False if not found
            
        Raises:
            {{ model_name }}ServiceException: If deletion fails
            
        Example:
            >>> success = await service.delete_{{ model_name.lower() }}(123)
            >>> if success:
            ...     print("{{ model_name }} deleted successfully")
        """
        try:
            logger.info(f"Deleting {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}")
            success = await self.repository.remove({{ model_name.lower() }}_id)
            
            if success:
                logger.info(f"Deleted {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}")
            else:
                logger.warning(f"{{ model_name }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }} not found for deletion")
                
            return success
            
        except Exception as e:
            logger.error(f"Failed to delete {{ model_name.lower() }} {{ '{' }}{{ model_name.lower() }}_id{{ '}' }}: {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to delete {{ model_name.lower() }}: {str(e)}",
                operation="delete_{{ model_name.lower() }}"
            ) from e

    async def list_{{ model_name.lower() }}s(
        self,
        page: int = 1,
        size: int = 10,
        name_filter: str | None = None
    ) -> {{ model_name }}List:
        """
        List {{ model_name.lower() }}s with pagination and filtering.
        
        Args:
            page: Page number (1-based)
            size: Number of items per page
            name_filter: Optional name filter (partial match)
            
        Returns:
            Paginated list of {{ model_name.lower() }}s
            
        Raises:
            {{ model_name }}ServiceException: If listing fails
            
        Example:
            >>> result = await service.list_{{ model_name.lower() }}s(
            ...     page=1, 
            ...     size=20, 
            ...     name_filter="test"
            ... )
            >>> print(f"Found {result.total} {{ model_name.lower() }}s")
        """
        try:
            # Prepare filters
            filters = {}
            if name_filter:
                filters["name__ilike"] = f"%{name_filter}%"
            
            logger.debug(f"Listing {{ model_name.lower() }}s: page={page}, size={size}, filters={filters}")
            result = await self.repository.list_active(
                page=page,
                size=size,
                filters=filters
            )
            
            logger.debug(f"Listed {len(result.items)} {{ model_name.lower() }}s out of {result.total}")
            return result
            
        except Exception as e:
            logger.error(f"Failed to list {{ model_name.lower() }}s: {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to list {{ model_name.lower() }}s: {str(e)}",
                operation="list_{{ model_name.lower() }}s"
            ) from e

    async def get_{{ model_name.lower() }}_by_name(self, name: str) -> {{ model_name }}Response | None:
        """
        Get {{ model_name.lower() }} by name.
        
        Args:
            name: Name to search for
            
        Returns:
            {{ model_name }} response if found
            
        Example:
            >>> {{ model_name.lower() }} = await service.get_{{ model_name.lower() }}_by_name("Sample {{ model_name }}")
        """
        try:
            entity = await self.repository.get_by_name(name)
            if entity:
                return {{ model_name }}Response.model_validate(entity)
            return None
        except Exception as e:
            logger.error(f"Failed to get {{ model_name.lower() }} by name '{name}': {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to get {{ model_name.lower() }} by name: {str(e)}",
                operation="get_{{ model_name.lower() }}_by_name"
            ) from e

    # Private validation methods

    async def _validate_create_data(self, create_data: {{ model_name }}Create) -> None:
        """Validate data for creating {{ model_name.lower() }}."""
        # Check if name already exists
        if await self.repository.exists_by_name(create_data.name):
            raise {{ model_name }}ValidationException(
                f"{{ model_name }} with name '{create_data.name}' already exists",
                validation_errors=[{"field": "name", "message": "Name already exists"}]
            )

    async def _validate_update_data(self, update_data: {{ model_name }}Update, {{ model_name.lower() }}_id: int) -> None:
        """Validate data for updating {{ model_name.lower() }}."""
        # Check if name already exists (excluding current entity)
        if update_data.name:
            existing = await self.repository.get_by_name(update_data.name)
            if existing and existing.id != {{ model_name.lower() }}_id:
                raise {{ model_name }}ValidationException(
                    f"{{ model_name }} with name '{update_data.name}' already exists",
                    validation_errors=[{"field": "name", "message": "Name already exists"}]
                ) 