"""
{{ model_name }} Pydantic schemas for Enterprise level.

This file was auto-generated by Autogen CLI.
Application: {{ app_name }}
Level: {{ level }}
Generated at: {{ timestamp }}
Template Version: v1.0.0 (Complete)
"""

from typing import Any, Literal
from uuid import UUID
from datetime import datetime

from pydantic import BaseModel, Field, ConfigDict, field_validator
from core.base.models import BaseSchema


class {{ model_name }}Base(BaseModel):
    """
    Base {{ model_name }} schema with common fields for Enterprise level.
    
    This schema contains the common fields that are used across
    different {{ model_name }} schemas with enterprise features.
    
    Add your custom fields here based on your model definition.
    """
    
    # Add your custom fields here based on your model
    # Example for Enterprise level:
    # title: str = Field(..., min_length=1, max_length=200, description="{{ model_name }} title")
    # content: str | None = Field(None, max_length=10000, description="Content text")
    # status: str = Field(default="draft", description="Status (draft, published, archived)")
    # priority: int = Field(default=0, ge=0, le=10, description="Priority level (0-10)")
    # tags: list[str] = Field(default_factory=list, description="List of tags")
    # metadata: dict[str, Any] = Field(default_factory=dict, description="Additional metadata")
    # tenant_id: UUID = Field(..., description="Tenant identifier for multi-tenancy")
    # external_id: str | None = Field(None, max_length=100, description="External system identifier")
    # version: int = Field(default=1, description="Record version for optimistic locking")
    
    pass


class {{ model_name }}Create({{ model_name }}Base):
    """
    Schema for creating a new {{ model_name }} with Enterprise features.
    
    This schema defines the required and optional fields
    for creating a new {{ model_name }} instance with enterprise validation.
    
    Example:
        >>> data = {{ model_name }}Create(
        ...     title="New Enterprise {{ model_name }}",
        ...     content="Detailed content",
        ...     tags=["important", "business"],
        ...     priority=8,
        ...     status="draft",
        ...     tenant_id=uuid.uuid4()
        ... )
        >>> # Use with API endpoint: POST {{ api_config.prefix }}
    """
    pass


class {{ model_name }}Update(BaseModel):
    """
    Schema for updating an existing {{ model_name }} (Enterprise level).
    
    All fields are optional to support partial updates.
    Only the provided fields will be updated.
    Supports optimistic locking with version field.
    
    Example:
        >>> data = {{ model_name }}Update(
        ...     title="Updated Title",
        ...     priority=9,
        ...     tags=["updated", "important"],
        ...     version=1  # For optimistic locking
        ... )
        >>> # Use with API endpoint: PUT {{ api_config.prefix }}/{id}
    """
    
    # Add your custom update fields here (all optional)
    # Example for Enterprise level:
    # title: str | None = Field(None, min_length=1, max_length=200, description="Updated title")
    # content: str | None = Field(None, max_length=10000, description="Updated content")
    # status: str | None = Field(None, description="Updated status")
    # priority: int | None = Field(None, ge=0, le=10, description="Updated priority")
    # tags: list[str] | None = Field(None, description="Updated tags list")
    # metadata: dict[str, Any] | None = Field(None, description="Updated metadata")
    # external_id: str | None = Field(None, max_length=100, description="Updated external ID")
    # version: int | None = Field(None, description="Current version for optimistic locking")
    
    pass


class {{ model_name }}Response(BaseSchema):
    """
    Schema for {{ model_name }} responses (Enterprise level).
    
    This schema is used when returning {{ model_name }} data
    from API endpoints. It includes all fields from the database
    plus computed fields and enterprise metadata.
    
    Inherits base fields from BaseSchema:
    - id: UUID
    - created_at: datetime
    - updated_at: datetime
    - deleted_at: datetime | None
    - is_deleted: bool
    
    Example:
        >>> response = {{ model_name }}Response.model_validate(db_{{ model_name.lower() }})
        >>> # Returned from API endpoints: GET {{ api_config.prefix }}
    """
    
    model_config = ConfigDict(from_attributes=True)
    
    # Add your custom response fields here
    # Example for Enterprise level:
    # title: str = Field(..., description="{{ model_name }} title")
    # content: str | None = Field(None, description="Content text")
    # status: str = Field(..., description="Current status")
    # priority: int = Field(..., description="Priority level")
    # tags: list[str] = Field(default_factory=list, description="List of tags")
    # metadata: dict[str, Any] = Field(default_factory=dict, description="Additional metadata")
    # tenant_id: UUID = Field(..., description="Tenant identifier")
    # external_id: str | None = Field(None, description="External system identifier")
    # version: int = Field(..., description="Record version")
    
    # Enterprise-specific computed fields
    cache_status: str | None = Field(default=None, description="Cache status (hit/miss/disabled)")
    tenant_info: dict[str, Any] | None = Field(default=None, description="Tenant information")
    performance_metrics: dict[str, float] | None = Field(default=None, description="Performance metrics")
    event_metadata: dict[str, Any] | None = Field(default=None, description="Event processing metadata")
    
    pass


class {{ model_name }}List(BaseModel):
    """Schema for paginated {{ model_name }} list responses (Enterprise level)."""
    
    items: list[{{ model_name }}Response] = Field(default_factory=list, description="List of {{ model_name.lower() }}s")
    total: int = Field(default=0, ge=0, description="Total number of {{ model_name.lower() }}s matching filters")
    
    {% if features.enable_pagination %}
    page: int = Field(default=1, ge=1, description="Current page number")
    size: int = Field(default=20, ge=1, le=100, description="Number of items per page")
    pages: int = Field(default=1, ge=0, description="Total number of pages")
    {% endif %}

    # Enterprise-specific metadata
    filters_applied: dict[str, Any] = Field(default_factory=dict, description="Applied filters summary")
    facets: dict[str, dict[str, int]] | None = Field(default=None, description="Faceted search results")
    search_time_ms: float | None = Field(default=None, description="Search execution time in milliseconds")
    cache_hit_ratio: float | None = Field(default=None, description="Cache hit ratio for this query")
    tenant_id: UUID | None = Field(default=None, description="Tenant identifier")


class {{ model_name }}SearchRequest(BaseModel):
    """Schema for Enterprise-level search requests."""
    
    query: str | None = Field(default=None, max_length=500, description="Full-text search query")
    search_fields: list[str] | None = Field(default=None, description="Fields to search in")
    sort_by: str = Field(default="created_at", description="Sort field")
    sort_order: Literal["asc", "desc"] = Field(default="desc", description="Sort order")
    page: int = Field(default=1, ge=1, description="Page number")
    size: int = Field(default=20, ge=1, le=100, description="Items per page")
    
    # Enterprise features
    include_facets: bool = Field(default=False, description="Include faceted search results")
    include_aggregations: bool = Field(default=False, description="Include aggregation results")
    include_performance_metrics: bool = Field(default=False, description="Include performance metrics")
    tenant_id: UUID | None = Field(default=None, description="Tenant identifier for multi-tenancy")
    use_cache: bool = Field(default=True, description="Whether to use cache for this query")

    @field_validator('search_fields')
    @classmethod
    def validate_search_fields(cls, v: list[str] | None) -> list[str] | None:
        """Validate search fields."""
        if v is not None:
            v = list(set(field.strip() for field in v if field.strip()))
            if len(v) > 10:  # Enterprise allows more fields
                raise ValueError("Maximum 10 search fields allowed")
        return v


class {{ model_name }}Filter(BaseModel):
    """Schema for filtering {{ model_name }} queries (Enterprise level)."""
    
    # Base filters
    id: UUID | None = None
    created_at__gte: datetime | None = None
    created_at__lte: datetime | None = None
    updated_at__gte: datetime | None = None
    updated_at__lte: datetime | None = None
    deleted_at__isnull: bool | None = None
    
    # Enterprise-specific filters
    tenant_id: UUID | None = None
    search_query: str | None = None
    search_fields: list[str] | None = None
    
    # Add custom filters based on your model fields here
    # Example for Enterprise level:
    # title__icontains: str | None = None
    # content__search: str | None = None
    # status__in: list[str] | None = None
    # priority__gte: int | None = None
    # priority__lte: int | None = None
    # tags__contains: str | None = None
    # metadata__has_key: str | None = None
    # external_id__exact: str | None = None
    # version__gte: int | None = None
    
    model_config = ConfigDict(extra='allow')


class {{ model_name }}BulkRequest(BaseModel):
    """Schema for bulk operations (Enterprise level)."""
    
    operation: Literal["create", "update", "delete"] = Field(..., description="Bulk operation type")
    items: list[dict[str, Any]] = Field(..., description="Items to process")
    batch_size: int = Field(default=100, ge=1, le=1000, description="Batch processing size")
    parallel_processing: bool = Field(default=False, description="Enable parallel processing")
    tenant_id: UUID | None = Field(default=None, description="Tenant identifier")
    
    @field_validator('items')
    @classmethod
    def validate_items(cls, v: list[dict[str, Any]]) -> list[dict[str, Any]]:
        """Validate items list."""
        if len(v) > 10000:  # Enterprise limit
            raise ValueError("Maximum 10000 items allowed per bulk operation")
        return v


class {{ model_name }}BulkResponse(BaseModel):
    """Schema for bulk operation responses."""
    
    total_items: int = Field(..., description="Total items processed")
    successful_items: int = Field(..., description="Successfully processed items")
    failed_items: int = Field(..., description="Failed items count")
    errors: list[dict[str, Any]] = Field(default_factory=list, description="List of errors")
    processing_time_ms: float = Field(..., description="Total processing time in milliseconds")
    tenant_id: UUID | None = Field(default=None, description="Tenant identifier")


class {{ model_name }}PerformanceMetrics(BaseModel):
    """Schema for performance metrics."""
    
    query_time_ms: float = Field(..., description="Query execution time in milliseconds")
    cache_hit_ratio: float = Field(..., description="Cache hit ratio")
    memory_usage_mb: float = Field(..., description="Memory usage in MB")
    cpu_usage_percent: float = Field(..., description="CPU usage percentage")
    network_io_bytes: int = Field(..., description="Network I/O in bytes")
    disk_io_bytes: int = Field(..., description="Disk I/O in bytes")
    tenant_id: UUID | None = Field(default=None, description="Tenant identifier")


class {{ model_name }}EventLog(BaseModel):
    """Schema for event logging."""
    
    event_id: UUID = Field(..., description="Event identifier")
    event_type: str = Field(..., description="Type of event")
    entity_id: UUID = Field(..., description="Entity identifier")
    tenant_id: UUID | None = Field(default=None, description="Tenant identifier")
    user_id: UUID | None = Field(default=None, description="User identifier")
    metadata: dict[str, Any] = Field(default_factory=dict, description="Event metadata")
    timestamp: datetime = Field(..., description="Event timestamp")
    correlation_id: UUID | None = Field(default=None, description="Correlation identifier")


class {{ model_name }}HealthCheck(BaseModel):
    """Schema for health check responses."""
    
    status: Literal["healthy", "degraded", "unhealthy"] = Field(..., description="Overall health status")
    checks: dict[str, dict[str, Any]] = Field(default_factory=dict, description="Individual health checks")
    timestamp: datetime = Field(..., description="Health check timestamp")
    tenant_id: UUID | None = Field(default=None, description="Tenant identifier")
    response_time_ms: float = Field(..., description="Health check response time")


class {{ model_name }}AuditLog(BaseModel):
    """Schema for audit logging."""
    
    audit_id: UUID = Field(..., description="Audit log identifier")
    action: str = Field(..., description="Action performed")
    entity_id: UUID = Field(..., description="Entity identifier")
    entity_type: str = Field(..., description="Entity type")
    tenant_id: UUID | None = Field(default=None, description="Tenant identifier")
    user_id: UUID | None = Field(default=None, description="User identifier")
    changes: dict[str, Any] = Field(default_factory=dict, description="Changes made")
    metadata: dict[str, Any] = Field(default_factory=dict, description="Additional metadata")
    timestamp: datetime = Field(..., description="Audit timestamp")
    ip_address: str | None = Field(default=None, description="Client IP address")
    user_agent: str | None = Field(default=None, description="Client user agent")


# Convenient type aliases for better code readability
{{ model_name }}CreateData = {{ model_name }}Create
{{ model_name }}UpdateData = {{ model_name }}Update
{{ model_name }}ResponseData = {{ model_name }}Response
{{ model_name }}FilterData = {{ model_name }}Filter
{{ model_name }}SearchData = {{ model_name }}SearchRequest
{{ model_name }}BulkData = {{ model_name }}BulkRequest
{{ model_name }}MetricsData = {{ model_name }}PerformanceMetrics
{{ model_name }}EventData = {{ model_name }}EventLog
{{ model_name }}HealthData = {{ model_name }}HealthCheck
{{ model_name }}AuditData = {{ model_name }}AuditLog
