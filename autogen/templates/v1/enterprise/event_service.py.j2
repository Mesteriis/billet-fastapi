"""
{{ model_name }} event service for Enterprise level.

This file was auto-generated by Autogen CLI.
Application: {{ app_name }}
Level: {{ level }}
Generated at: {{ timestamp }}
Template Version: v2.0.0
"""

import asyncio
import json
from datetime import datetime
from typing import Any, Dict, List, Optional, Callable, Union
from dataclasses import dataclass, asdict
from enum import Enum
import logging
import uuid

from pydantic import BaseModel, Field

logger = logging.getLogger("events.{{ app_name }}")


class EventType(str, Enum):
    """{{ model_name }} event types."""
    CREATED = "{{ model_name.lower() }}.created"
    UPDATED = "{{ model_name.lower() }}.updated"
    DELETED = "{{ model_name.lower() }}.deleted"
    STATUS_CHANGED = "{{ model_name.lower() }}.status_changed"
    PRIORITY_CHANGED = "{{ model_name.lower() }}.priority_changed"
    TAGS_UPDATED = "{{ model_name.lower() }}.tags_updated"
    BULK_UPDATED = "{{ model_name.lower() }}.bulk_updated"
    CACHE_INVALIDATED = "{{ model_name.lower() }}.cache_invalidated"
    SEARCH_PERFORMED = "{{ model_name.lower() }}.search_performed"


class EventPriority(str, Enum):
    """Event priority levels."""
    LOW = "low"
    NORMAL = "normal"
    HIGH = "high"
    CRITICAL = "critical"


@dataclass
class EventMetadata:
    """Event metadata information."""
    correlation_id: str
    user_id: Optional[int] = None
    session_id: Optional[str] = None
    request_id: Optional[str] = None
    source: str = "{{ app_name }}_service"
    version: str = "1.0"
    environment: str = "production"


class DomainEvent(BaseModel):
    """
    Base domain event class for {{ model_name }} operations.
    
    This represents an event that occurred in the {{ model_name }} domain
    and should be published to interested subscribers.
    
    Example:
        >>> event = DomainEvent(
        ...     event_id="evt_123",
        ...     event_type=EventType.CREATED,
        ...     entity_id=123,
        ...     payload={"name": "New Item"},
        ...     metadata=EventMetadata(correlation_id="corr_456")
        ... )
    """
    
    event_id: str = Field(default_factory=lambda: f"evt_{uuid.uuid4().hex[:8]}")
    event_type: EventType = Field(..., description="Type of event")
    entity_id: int = Field(..., description="ID of the affected entity")
    entity_type: str = Field(default="{{ model_name }}", description="Type of entity")
    
    payload: Dict[str, Any] = Field(default_factory=dict, description="Event payload data")
    previous_state: Optional[Dict[str, Any]] = Field(None, description="Previous entity state")
    current_state: Optional[Dict[str, Any]] = Field(None, description="Current entity state")
    
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    priority: EventPriority = Field(default=EventPriority.NORMAL)
    metadata: EventMetadata = Field(..., description="Event metadata")
    
    # Event processing
    retry_count: int = Field(default=0, description="Number of processing retries")
    max_retries: int = Field(default=3, description="Maximum retry attempts")
    processed: bool = Field(default=False, description="Whether event was processed")
    error_message: Optional[str] = Field(None, description="Error message if processing failed")
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert event to dictionary for serialization."""
        return {
            "event_id": self.event_id,
            "event_type": self.event_type.value,
            "entity_id": self.entity_id,
            "entity_type": self.entity_type,
            "payload": self.payload,
            "previous_state": self.previous_state,
            "current_state": self.current_state,
            "timestamp": self.timestamp.isoformat(),
            "priority": self.priority.value,
            "metadata": asdict(self.metadata),
            "retry_count": self.retry_count,
            "max_retries": self.max_retries,
            "processed": self.processed,
            "error_message": self.error_message
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "DomainEvent":
        """Create event from dictionary."""
        metadata_data = data.pop("metadata", {})
        metadata = EventMetadata(**metadata_data)
        
        return cls(
            event_id=data["event_id"],
            event_type=EventType(data["event_type"]),
            entity_id=data["entity_id"],
            entity_type=data.get("entity_type", "{{ model_name }}"),
            payload=data.get("payload", {}),
            previous_state=data.get("previous_state"),
            current_state=data.get("current_state"),
            timestamp=datetime.fromisoformat(data["timestamp"]),
            priority=EventPriority(data.get("priority", "normal")),
            metadata=metadata,
            retry_count=data.get("retry_count", 0),
            max_retries=data.get("max_retries", 3),
            processed=data.get("processed", False),
            error_message=data.get("error_message")
        )


class EventHandler:
    """Base event handler interface."""
    
    def __init__(self, name: str):
        self.name = name
        self.logger = logging.getLogger(f"events.handlers.{name}")
    
    async def handle(self, event: DomainEvent) -> bool:
        """
        Handle domain event.
        
        Args:
            event: The domain event to handle
            
        Returns:
            True if handled successfully, False otherwise
        """
        raise NotImplementedError
    
    def can_handle(self, event_type: EventType) -> bool:
        """Check if this handler can process the event type."""
        return True  # Override in subclasses


class CacheInvalidationHandler(EventHandler):
    """Handler for cache invalidation on entity changes."""
    
    def __init__(self, cache_service):
        super().__init__("cache_invalidation")
        self.cache_service = cache_service
    
    def can_handle(self, event_type: EventType) -> bool:
        """Handle cache-affecting events."""
        return event_type in [
            EventType.CREATED,
            EventType.UPDATED,
            EventType.DELETED,
            EventType.STATUS_CHANGED,
            EventType.BULK_UPDATED
        ]
    
    async def handle(self, event: DomainEvent) -> bool:
        """Invalidate relevant cache entries."""
        try:
            # Invalidate entity cache
            await self.cache_service.delete_entity(event.entity_id)
            
            # Invalidate search and list caches
            await self.cache_service.invalidate_pattern("search:*")
            await self.cache_service.invalidate_pattern("list:*")
            
            # Invalidate statistics
            await self.cache_service.invalidate_by_tag("stats")
            
            self.logger.info(f"Cache invalidated for entity {event.entity_id}")
            return True
            
        except Exception as e:
            self.logger.error(f"Cache invalidation failed: {e}")
            return False


class NotificationHandler(EventHandler):
    """Handler for sending notifications on important events."""
    
    def __init__(self):
        super().__init__("notifications")
    
    def can_handle(self, event_type: EventType) -> bool:
        """Handle notification-worthy events."""
        return event_type in [
            EventType.CREATED,
            EventType.STATUS_CHANGED,
            EventType.PRIORITY_CHANGED
        ]
    
    async def handle(self, event: DomainEvent) -> bool:
        """Send notifications for important events."""
        try:
            if event.event_type == EventType.CREATED:
                await self._send_creation_notification(event)
            elif event.event_type == EventType.STATUS_CHANGED:
                await self._send_status_change_notification(event)
            elif event.event_type == EventType.PRIORITY_CHANGED:
                await self._send_priority_change_notification(event)
            
            return True
            
        except Exception as e:
            self.logger.error(f"Notification sending failed: {e}")
            return False
    
    async def _send_creation_notification(self, event: DomainEvent):
        """Send notification for entity creation."""
        self.logger.info(f"{{ model_name }} {event.entity_id} created")
        # Implement actual notification logic (email, webhook, etc.)
    
    async def _send_status_change_notification(self, event: DomainEvent):
        """Send notification for status change."""
        old_status = event.previous_state.get("status") if event.previous_state else "unknown"
        new_status = event.current_state.get("status") if event.current_state else "unknown"
        self.logger.info(f"{{ model_name }} {event.entity_id} status changed: {old_status} → {new_status}")
    
    async def _send_priority_change_notification(self, event: DomainEvent):
        """Send notification for priority change."""
        old_priority = event.previous_state.get("priority") if event.previous_state else 0
        new_priority = event.current_state.get("priority") if event.current_state else 0
        self.logger.info(f"{{ model_name }} {event.entity_id} priority changed: {old_priority} → {new_priority}")


class AuditLogHandler(EventHandler):
    """Handler for audit logging."""
    
    def __init__(self):
        super().__init__("audit_log")
    
    async def handle(self, event: DomainEvent) -> bool:
        """Log event for audit purposes."""
        try:
            audit_entry = {
                "timestamp": event.timestamp.isoformat(),
                "event_id": event.event_id,
                "event_type": event.event_type.value,
                "entity_id": event.entity_id,
                "user_id": event.metadata.user_id,
                "changes": self._extract_changes(event),
                "correlation_id": event.metadata.correlation_id
            }
            
            # Log to audit system (database, file, external service)
            self.logger.info(f"AUDIT: {json.dumps(audit_entry)}")
            return True
            
        except Exception as e:
            self.logger.error(f"Audit logging failed: {e}")
            return False
    
    def _extract_changes(self, event: DomainEvent) -> Dict[str, Any]:
        """Extract changes between previous and current state."""
        if not event.previous_state or not event.current_state:
            return {}
        
        changes = {}
        for key, new_value in event.current_state.items():
            old_value = event.previous_state.get(key)
            if old_value != new_value:
                changes[key] = {"from": old_value, "to": new_value}
        
        return changes


class {{ model_name }}EventService:
    """
    Enterprise event service for {{ model_name }} domain events.
    
    Features:
    - Event publishing and subscription
    - Asynchronous event processing
    - Event replay and reprocessing
    - Dead letter queue for failed events
    - Event handlers with retry logic
    {% if features.enable_events %}- Integration with message queue{% endif %}
    
    Example:
        >>> event_service = {{ model_name }}EventService()
        >>> 
        >>> # Register handlers
        >>> event_service.subscribe(CacheInvalidationHandler(cache_service))
        >>> event_service.subscribe(NotificationHandler())
        >>> 
        >>> # Publish events
        >>> await event_service.publish(EventType.CREATED, entity_id=123, payload=data)
        >>> 
        >>> # Process events
        >>> await event_service.process_events()
    """
    
    def __init__(self):
        """Initialize event service."""
        self.handlers: List[EventHandler] = []
        self.event_queue: asyncio.Queue = asyncio.Queue()
        self.dead_letter_queue: List[DomainEvent] = []
        self.processing = False
        self.metrics = {
            "published": 0,
            "processed": 0,
            "failed": 0,
            "retried": 0
        }
    
    def subscribe(self, handler: EventHandler) -> None:
        """Subscribe event handler."""
        self.handlers.append(handler)
        logger.info(f"Registered event handler: {handler.name}")
    
    def unsubscribe(self, handler: EventHandler) -> None:
        """Unsubscribe event handler."""
        if handler in self.handlers:
            self.handlers.remove(handler)
            logger.info(f"Unregistered event handler: {handler.name}")
    
    async def publish(
        self,
        event_type: EventType,
        entity_id: int,
        payload: Dict[str, Any] = None,
        metadata: EventMetadata = None,
        priority: EventPriority = EventPriority.NORMAL,
        previous_state: Dict[str, Any] = None,
        current_state: Dict[str, Any] = None
    ) -> str:
        """
        Publish domain event.
        
        Args:
            event_type: Type of event
            entity_id: ID of affected entity
            payload: Event payload data
            metadata: Event metadata
            priority: Event priority
            previous_state: Previous entity state
            current_state: Current entity state
            
        Returns:
            Event ID
        """
        if metadata is None:
            metadata = EventMetadata(correlation_id=f"corr_{uuid.uuid4().hex[:8]}")
        
        event = DomainEvent(
            event_type=event_type,
            entity_id=entity_id,
            payload=payload or {},
            metadata=metadata,
            priority=priority,
            previous_state=previous_state,
            current_state=current_state
        )
        
        await self.event_queue.put(event)
        self.metrics["published"] += 1
        
        logger.debug(f"Published event {event.event_id}: {event_type.value}")
        return event.event_id
    
    async def process_events(self) -> None:
        """Process events from queue."""
        if self.processing:
            return
        
        self.processing = True
        logger.info("Started event processing")
        
        try:
            while not self.event_queue.empty():
                try:
                    event = await asyncio.wait_for(self.event_queue.get(), timeout=1.0)
                    await self._process_event(event)
                    self.event_queue.task_done()
                except asyncio.TimeoutError:
                    break
                except Exception as e:
                    logger.error(f"Event processing error: {e}")
        finally:
            self.processing = False
            logger.info("Event processing completed")
    
    async def _process_event(self, event: DomainEvent) -> None:
        """Process single event with all handlers."""
        logger.debug(f"Processing event {event.event_id}: {event.event_type.value}")
        
        handlers_to_run = [h for h in self.handlers if h.can_handle(event.event_type)]
        
        if not handlers_to_run:
            logger.warning(f"No handlers found for event type: {event.event_type.value}")
            return
        
        success_count = 0
        
        for handler in handlers_to_run:
            try:
                success = await handler.handle(event)
                if success:
                    success_count += 1
                    logger.debug(f"Handler {handler.name} processed event {event.event_id}")
                else:
                    logger.warning(f"Handler {handler.name} failed to process event {event.event_id}")
                    
            except Exception as e:
                logger.error(f"Handler {handler.name} error for event {event.event_id}: {e}")
        
        if success_count == len(handlers_to_run):
            event.processed = True
            self.metrics["processed"] += 1
        else:
            await self._handle_failed_event(event)
    
    async def _handle_failed_event(self, event: DomainEvent) -> None:
        """Handle failed event with retry logic."""
        event.retry_count += 1
        
        if event.retry_count <= event.max_retries:
            # Retry with exponential backoff
            delay = 2 ** event.retry_count
            logger.info(f"Retrying event {event.event_id} in {delay} seconds (attempt {event.retry_count})")
            
            await asyncio.sleep(delay)
            await self.event_queue.put(event)
            self.metrics["retried"] += 1
        else:
            # Move to dead letter queue
            logger.error(f"Event {event.event_id} failed after {event.max_retries} retries")
            self.dead_letter_queue.append(event)
            self.metrics["failed"] += 1
    
    async def replay_event(self, event_id: str) -> bool:
        """Replay event from dead letter queue."""
        for i, event in enumerate(self.dead_letter_queue):
            if event.event_id == event_id:
                # Reset retry count and requeue
                event.retry_count = 0
                event.processed = False
                event.error_message = None
                
                await self.event_queue.put(event)
                self.dead_letter_queue.pop(i)
                
                logger.info(f"Replaying event {event_id}")
                return True
        
        logger.warning(f"Event {event_id} not found in dead letter queue")
        return False
    
    def get_metrics(self) -> Dict[str, Any]:
        """Get event processing metrics."""
        return {
            "metrics": self.metrics.copy(),
            "queue_size": self.event_queue.qsize(),
            "dead_letter_count": len(self.dead_letter_queue),
            "handlers_count": len(self.handlers),
            "processing": self.processing
        }
    
    def get_dead_letter_events(self) -> List[Dict[str, Any]]:
        """Get events in dead letter queue."""
        return [event.to_dict() for event in self.dead_letter_queue]


# Factory functions for common event scenarios

async def create_{{ model_name.lower() }}_created_event(
    entity_id: int,
    entity_data: Dict[str, Any],
    user_id: Optional[int] = None
) -> DomainEvent:
    """Create entity creation event."""
    metadata = EventMetadata(
        correlation_id=f"create_{entity_id}_{uuid.uuid4().hex[:8]}",
        user_id=user_id
    )
    
    return DomainEvent(
        event_type=EventType.CREATED,
        entity_id=entity_id,
        payload=entity_data,
        current_state=entity_data,
        metadata=metadata,
        priority=EventPriority.NORMAL
    )


async def create_{{ model_name.lower() }}_updated_event(
    entity_id: int,
    previous_data: Dict[str, Any],
    current_data: Dict[str, Any],
    user_id: Optional[int] = None
) -> DomainEvent:
    """Create entity update event."""
    # Extract changes
    changes = {}
    for key, new_value in current_data.items():
        old_value = previous_data.get(key)
        if old_value != new_value:
            changes[key] = {"from": old_value, "to": new_value}
    
    metadata = EventMetadata(
        correlation_id=f"update_{entity_id}_{uuid.uuid4().hex[:8]}",
        user_id=user_id
    )
    
    # Determine priority based on changes
    priority = EventPriority.HIGH if "status" in changes or "priority" in changes else EventPriority.NORMAL
    
    return DomainEvent(
        event_type=EventType.UPDATED,
        entity_id=entity_id,
        payload=changes,
        previous_state=previous_data,
        current_state=current_data,
        metadata=metadata,
        priority=priority
    )


# Dependency injection
def get_event_service() -> {{ model_name }}EventService:
    """Get event service instance."""
    return {{ model_name }}EventService() 