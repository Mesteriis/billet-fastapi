"""
{{ model_name }} service implementation for Advanced level.

This file was auto-generated by Autogen CLI.
Application: {{ app_name }}
Level: {{ level }}
Generated at: {{ timestamp }}
"""

from typing import Any
import logging
import json

from sqlalchemy.ext.asyncio import AsyncSession

from apps.{{ app_name }}.repo.{{ app_name }}_repo import {{ model_name }}Repository
from apps.{{ app_name }}.schemas.{{ app_name }}_schemas import (
    {{ model_name }}Create,
    {{ model_name }}Update,
    {{ model_name }}Response,
    {{ model_name }}List,
    {{ model_name }}SearchRequest,
    {{ model_name }}Status
)
from apps.{{ app_name }}.exceptions import (
    {{ model_name }}ServiceException,
    {{ model_name }}ValidationException,
    {{ model_name }}AlreadyExistsError,
    {{ model_name }}NotFoundError
)

logger = logging.getLogger("{{ app_name }}.{{ model_name.lower() }}")


class {{ model_name }}Service:
    """
    Advanced service layer for {{ model_name }} business logic.
    
    This service provides advanced business logic operations including:
    - Complex validation and business rules
    - Full-text search with relevance scoring
    - Advanced filtering and faceted search
    - Priority and status management
    - Tag-based categorization
    - Comprehensive error handling
    {% if features.enable_soft_delete %}- Advanced soft delete operations{% endif %}
    
    Example:
        >>> async with async_session() as session:
        ...     service = {{ model_name }}Service(session)
        ...     
        ...     # Advanced search
        ...     search_request = {{ model_name }}SearchRequest(
        ...         query="business critical",
        ...         priority_gte=5,
        ...         status=["active", "draft"],
        ...         include_facets=True
        ...     )
        ...     results = await service.search_{{ model_name.lower() }}s(search_request)
    """

    def __init__(self, session: AsyncSession):
        """Initialize {{ model_name }} service."""
        self.session = session
        self.repository = {{ model_name }}Repository(session)

    async def create_{{ model_name.lower() }}(self, create_data: {{ model_name }}Create) -> {{ model_name }}Response:
        """Create a new {{ model_name.lower() }} with advanced validation."""
        try:
            await self._validate_create_data(create_data)
            
            # Process tags
            processed_data = create_data.model_copy()
            if processed_data.tags:
                processed_data.tags = json.dumps(processed_data.tags)
            
            logger.info(f"Creating advanced {{ model_name.lower() }}: {create_data.name}")
            entity = await self.repository.create(processed_data)
            
            return await self._build_response(entity)
            
        except ({{ model_name }}ValidationException, {{ model_name }}AlreadyExistsError):
            raise
        except Exception as e:
            logger.error(f"Failed to create {{ model_name.lower() }}: {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to create {{ model_name.lower() }}: {str(e)}",
                operation="create_{{ model_name.lower() }}"
            ) from e

    async def get_{{ model_name.lower() }}(self, {{ model_name.lower() }}_id: int) -> {{ model_name }}Response | None:
        """
        Get {{ model_name.lower() }} by ID with computed fields.
        
        Args:
            {{ model_name.lower() }}_id: ID of the {{ model_name.lower() }} to retrieve
            
        Returns:
            {{ model_name }} response with computed fields if found, None otherwise
            
        Raises:
            {{ model_name }}ServiceException: If retrieval fails
            
        Example:
            >>> {{ model_name.lower() }} = await service.get_{{ model_name.lower() }}(123)
            >>> if {{ model_name.lower() }}:
            ...     print(f"Found: {{{ model_name.lower() }}.name} (Priority: {{{ model_name.lower() }}.priority})")
        """
        try:
            logger.debug(f"Getting {{ model_name.lower() }} with ID: {{{ model_name.lower() }}_id}")
            entity = await self.repository.get({{ model_name.lower() }}_id)
            
            if entity:
                return await self._build_response(entity)
            return None
            
        except Exception as e:
            logger.error(f"Failed to get {{ model_name.lower() }} {{{ model_name.lower() }}_id}: {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to retrieve {{ model_name.lower() }}: {str(e)}",
                operation="get_{{ model_name.lower() }}"
            ) from e

    async def update_{{ model_name.lower() }}(
        self, 
        {{ model_name.lower() }}_id: int, 
        update_data: {{ model_name }}Update
    ) -> {{ model_name }}Response | None:
        """
        Update {{ model_name.lower() }} with advanced business validation.
        
        Args:
            {{ model_name.lower() }}_id: ID of the {{ model_name.lower() }} to update
            update_data: Data for updating the {{ model_name.lower() }}
            
        Returns:
            Updated {{ model_name.lower() }} response if found
            
        Raises:
            {{ model_name }}ValidationException: If validation fails
            {{ model_name }}NotFoundError: If {{ model_name.lower() }} not found
            {{ model_name }}ServiceException: If update fails
            
        Example:
            >>> data = {{ model_name }}Update(
            ...     name="Updated Name",
            ...     priority=9,
            ...     tags=["updated", "high-priority"]
            ... )
            >>> updated = await service.update_{{ model_name.lower() }}(123, data)
        """
        try:
            # Check if entity exists
            existing = await self.repository.get({{ model_name.lower() }}_id)
            if not existing:
                raise {{ model_name }}NotFoundError(
                    f"{{ model_name }} with ID {{{ model_name.lower() }}_id} not found",
                    entity_id={{ model_name.lower() }}_id
                )
            
            # Advanced business validation
            await self._validate_update_data(update_data, {{ model_name.lower() }}_id)
            
            # Process tags if provided
            processed_data = update_data.model_copy()
            if processed_data.tags is not None:
                processed_data.tags = json.dumps(processed_data.tags) if processed_data.tags else None
            
            # Update entity
            logger.info(f"Updating {{ model_name.lower() }} {{{ model_name.lower() }}_id}")
            entity = await self.repository.update({{ model_name.lower() }}_id, processed_data)
            
            if entity:
                response = await self._build_response(entity)
                logger.info(f"Updated {{ model_name.lower() }} {{{ model_name.lower() }}_id}")
                return response
            return None
            
        except ({{ model_name }}ValidationException, {{ model_name }}NotFoundError):
            raise
        except Exception as e:
            logger.error(f"Failed to update {{ model_name.lower() }} {{{ model_name.lower() }}_id}: {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to update {{ model_name.lower() }}: {str(e)}",
                operation="update_{{ model_name.lower() }}"
            ) from e

    async def delete_{{ model_name.lower() }}(self, {{ model_name.lower() }}_id: int) -> bool:
        """
        Delete {{ model_name.lower() }} by ID (soft delete if enabled).
        
        Args:
            {{ model_name.lower() }}_id: ID of the {{ model_name.lower() }} to delete
            
        Returns:
            True if deleted successfully, False if not found
            
        Raises:
            {{ model_name }}ServiceException: If deletion fails
            
        Example:
            >>> success = await service.delete_{{ model_name.lower() }}(123)
            >>> if success:
            ...     print("{{ model_name }} deleted successfully")
        """
        try:
            logger.info(f"Deleting {{ model_name.lower() }} {{{ model_name.lower() }}_id}")
            success = await self.repository.remove({{ model_name.lower() }}_id)
            
            if success:
                logger.info(f"Deleted {{ model_name.lower() }} {{{ model_name.lower() }}_id}")
            else:
                logger.warning(f"{{ model_name }} {{{ model_name.lower() }}_id} not found for deletion")
                
            return success
            
        except Exception as e:
            logger.error(f"Failed to delete {{ model_name.lower() }} {{{ model_name.lower() }}_id}: {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to delete {{ model_name.lower() }}: {str(e)}",
                operation="delete_{{ model_name.lower() }}"
            ) from e

    async def search_{{ model_name.lower() }}s(self, search_request: {{ model_name }}SearchRequest) -> {{ model_name }}List:
        """Advanced search with complex filtering."""
        try:
            logger.debug(f"Advanced search {{ model_name.lower() }}s")
            return await self.repository.complex_search(search_request)
        except Exception as e:
            logger.error(f"Failed to search {{ model_name.lower() }}s: {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to search {{ model_name.lower() }}s: {str(e)}",
                operation="search_{{ model_name.lower() }}s"
            ) from e

    async def get_{{ model_name.lower() }}_by_name(self, name: str, status: {{ model_name }}Status | None = None) -> {{ model_name }}Response | None:
        """
        Get {{ model_name.lower() }} by name with optional status filter.
        
        Args:
            name: Name to search for
            status: Optional status filter
            
        Returns:
            {{ model_name }} response if found
            
        Example:
            >>> {{ model_name.lower() }} = await service.get_{{ model_name.lower() }}_by_name("Project Alpha", "active")
        """
        try:
            entity = await self.repository.get_by_name_and_status(
                name, status or {{ model_name }}Status.ACTIVE
            )
            if entity:
                return await self._build_response(entity)
            return None
        except Exception as e:
            logger.error(f"Failed to get {{ model_name.lower() }} by name '{name}': {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to get {{ model_name.lower() }} by name: {str(e)}",
                operation="get_{{ model_name.lower() }}_by_name"
            ) from e

    async def update_priority(self, {{ model_name.lower() }}_id: int, priority: int) -> {{ model_name }}Response | None:
        """
        Update {{ model_name.lower() }} priority with validation.
        
        Args:
            {{ model_name.lower() }}_id: ID of the {{ model_name.lower() }} to update
            priority: New priority (0-10)
            
        Returns:
            Updated {{ model_name.lower() }} response
            
        Raises:
            {{ model_name }}ValidationException: If priority is invalid
            
        Example:
            >>> updated = await service.update_priority(123, 9)
        """
        if not (0 <= priority <= 10):
            raise {{ model_name }}ValidationException(
                "Priority must be between 0 and 10",
                validation_errors=[{"field": "priority", "message": "Invalid priority range"}]
            )
        
        update_data = {{ model_name }}Update(priority=priority)
        return await self.update_{{ model_name.lower() }}({{ model_name.lower() }}_id, update_data)

    async def add_tags(self, {{ model_name.lower() }}_id: int, tags: list[str]) -> {{ model_name }}Response | None:
        """
        Add tags to {{ model_name.lower() }}.
        
        Args:
            {{ model_name.lower() }}_id: ID of the {{ model_name.lower() }}
            tags: List of tags to add
            
        Returns:
            Updated {{ model_name.lower() }} response
            
        Example:
            >>> updated = await service.add_tags(123, ["urgent", "customer"])
        """
        entity = await self.repository.get({{ model_name.lower() }}_id)
        if not entity:
            raise {{ model_name }}NotFoundError(f"{{ model_name }} with ID {{{ model_name.lower() }}_id} not found")
        
        # Merge with existing tags
        existing_tags = set(entity.tags_list)
        new_tags = list(existing_tags.union(set(tags)))
        
        update_data = {{ model_name }}Update(tags=new_tags)
        return await self.update_{{ model_name.lower() }}({{ model_name.lower() }}_id, update_data)

    async def get_statistics(self) -> dict[str, Any]:
        """
        Get comprehensive statistics about {{ model_name.lower() }}s.
        
        Returns:
            Dictionary with various statistics
            
        Example:
            >>> stats = await service.get_statistics()
            >>> print(f"Total active: {stats['total_active']}")
        """
        try:
            # Get basic counts
            total_count = await self.repository.count()
            active_count = await self.repository.count(filters={"status": "active", "is_deleted": False})
            
            # Get priority stats
            priority_stats = await self.repository.get_priority_stats()
            
            # Get status counts
            status_counts = await self.repository.get_status_counts()
            
            return {
                "total_count": total_count,
                "active_count": active_count,
                "priority_stats": priority_stats,
                "status_counts": status_counts,
                "high_priority_count": len(await self.repository.get_by_priority_range(7, 10))
            }
            
        except Exception as e:
            logger.error(f"Failed to get statistics: {e}")
            raise {{ model_name }}ServiceException(
                f"Failed to get statistics: {str(e)}",
                operation="get_statistics"
            ) from e

    # Private helper methods

    async def _build_response(self, entity) -> {{ model_name }}Response:
        """Build response object with computed fields."""
        response = {{ model_name }}Response.model_validate(entity)
        response.tags_count = len(entity.tags_list) if entity.tags else 0
        response.is_high_priority = entity.priority >= 7
        return response

    async def _validate_create_data(self, create_data: {{ model_name }}Create) -> None:
        """Advanced validation for create data."""
        # Check business rules
        if create_data.priority > 8 and create_data.status != {{ model_name }}Status.ACTIVE:
            raise {{ model_name }}ValidationException(
                "High priority {{ model_name.lower() }}s (>8) must be active",
                validation_errors=[{"field": "status", "message": "High priority items must be active"}]
            )

    async def _validate_update_data(self, update_data: {{ model_name }}Update, {{ model_name.lower() }}_id: int) -> None:
        """Advanced validation for update data."""
        # Check if name already exists (excluding current entity)
        if update_data.name:
            existing = await self.repository.get_by_name_and_status(
                update_data.name, 
                update_data.status or {{ model_name }}Status.ACTIVE
            )
            if existing and existing.id != {{ model_name.lower() }}_id:
                raise {{ model_name }}ValidationException(
                    f"{{ model_name }} with name '{update_data.name}' already exists",
                    validation_errors=[{"field": "name", "message": "Name already exists"}]
                )
        
        # Validate business rules
        if update_data.priority and update_data.priority > 8:
            if update_data.status and update_data.status != {{ model_name }}Status.ACTIVE:
                raise {{ model_name }}ValidationException(
                    "High priority {{ model_name.lower() }}s (>8) must be active",
                    validation_errors=[{"field": "status", "message": "High priority items must be active"}]
                ) 